                                ;; Pacman sur NES
                                ;; Mouvement des fantômes et gestion des pilules
                                ;;
                                ;; Ce qu'il reste à faire :
                                ;; - Les différents comportement de chasse des fantômes
                                ;; - Déplacements à des vitesses différentes
                                ;; - Intro du jeu
                                ;; - Gestion et affichage du score
                                ;; - Intermission (animation entre les niveaux)
                                ;; - Fin du jeu (mort de pacman ou passage au niveau suivant)
                                ;; - Musique et bruitages
                                ;; - Supprimer les (nombreux !) bugs
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                
                                ;; Quelques définitions
                                ; Les registres (adresses) du PPU
                                PPUCTRL   EQU $2000
                                PPUMASK   EQU $2001
                                PPUSTATUS EQU $2002
                                OAMADDR   EQU $2003
                                OAMDATA   EQU $2004
                                PPUSCROLL EQU $2005
                                PPUADDR   EQU $2006
                                PPUDATA   EQU $2007
                                ; Quelques adresses/registres de l'APU
                                OAMDMA    EQU $4014
                                JOYPAD1   EQU $4016
                                
                                ;; Pour les sprites de Pacman et des fantômes
                                SPR_NW_Y    EQU $200
                                SPR_NW_TILE EQU $201
                                SPR_NW_ATTR EQU $202
                                SPR_NW_X    EQU $203
                                SPR_NE_Y    EQU $204
                                SPR_NE_TILE EQU $205
                                SPR_NE_ATTR EQU $206
                                SPR_NE_X    EQU $207
                                SPR_SW_Y    EQU $208
                                SPR_SW_TILE EQU $209
                                SPR_SW_ATTR EQU $20a
                                SPR_SW_X    EQU $20b
                                SPR_SE_Y    EQU $20c
                                SPR_SE_TILE EQU $20d
                                SPR_SE_ATTR EQU $20e
                                SPR_SE_X    EQU $20f
                                
                                ; Les valeurs possibles de pac_orientation
                                PACMAN_FACING_LEFT   EQU 0
                                PACMAN_FACING_RIGHT  EQU 1
                                PACMAN_FACING_UP     EQU 2
                                PACMAN_FACING_DOWN   EQU 3
                                
                                ; Les modes de déplacement des fantômes
                                GM_CORNER     EQU 0   ; Aller dans son coin
                                GM_CHASE      EQU 1   ; Pourchasser pacman
                                GM_FRIGHTENED EQU 2   ; Errer au hasard (Pacman vient de manger une pac-gomme)
                                GM_EATEN      EQU 3   ; Retour à l'enclos après avoir été mangé
                                GM_IN_PEN     EQU 4   ; Dans l'enclos, avec une bonne envie de sortir
                                GM_WAITING    EQU 5   ; Dans l'enclos, immobile, en attendant de sortir
                                
                                ; Nombre total de pilules dans le labyrinthe (pour tester la fin du niveau)
                                TOTAL_NB_PILLS EQU 244
                                ; Différents timers (probablement à améliorer)
                                FRIGHTENED_TIMER_HIGH EQU 3   ; Temps pendant lequel les fantômes restent effrayés
                                FRIGHTENED_TIMER_LOW  EQU 10  ; 3*256+10 = 778 frames
                                CHASE_TIMER_HIGH      EQU 7   ; Temps pendant lequel les fantômes pourchassent Pacman
                                CHASE_TIMER_LOW       EQU 23  ;   avant de repasser en mode "coin"
                                CORNER_TIMER_HIGH     EQU 8   ; Temps pendant lequel les fantômes vont dans leur coin
                                CORNER_TIMER_LOW      EQU 47  ;   avant de repasser en mode pourchasse
                                
                                  ENUM $0000  ; Les variables "rapides"
00000                           seed                         DS.B 1  ; Valeur aléatoire courante
00001                           vbl_cnt                      DS.B 1  ; Compteur de VBL (50 Hz)
00002                           vbl_flag                     DS.B 1  ; Mis à 1 par la VBL
00003                           scroll_offset                DS.B 1  ; Le décalage de l'écran
00004                           jump_address_pointer         DS.B 2  ; Pointeur sur l'adresse de saut pour la fonction on_goto
00006                           jump_address                 DS.B 2  ; Adresse de saut pour la fonction on_goto
00008                             ; Variables pour les paramètres de fonctions
00008                           param_x                      DS.B 1  ; Position en X de la case à tester
00009                           param_y                      DS.B 1  ;             Y
0000A                           tmp_var                      DS.B 10 ; Variables locales
00014                             ; Variables pour l'algo des fantômes
00014                           ghost_current                DS.B 1  ; Numéro du fantôme actuel (de 0 à 3)
00015                           ghost_direction_index        DS.B 1  ; Numéro de la direction actuelle (de 0 à 3, voir direction_table_x et direction_table_y)
00016                           ghost_direction_min_index    DS.B 1  ; Numéro de la direction qui a la plus petite distance
00017                           ghost_new_position_x         DS.B 1  ; Position en X du fantôme courant s'il allait dans la direction actuelle
00018                           ghost_new_position_y         DS.B 1  ;             Y
00019                           ghost_distance_x_to_target   DS.B 2  ; (carré de la) distance entre le fantôme et sa cible, en X
0001B                           ghost_distance_y_to_target   DS.B 2  ; (carré de la) distance entre le fantôme et sa cible, en Y
0001D                           ghost_distance_to_target     DS.B 2  ; (carré de la) distance entre le fantôme et sa cible
0001F                           ghost_distance_min_to_target DS.B 2  ; Minimum des (carrés des) distances entre le fantôme et sa cible
00021                           ghost_anim_offset            DS.B 1  ; Animation des fantômes (direction du regard et animation de la robe)
00022                             ENDE
                                
                                  ENUM $0300  ; Les variables "normales"
00300                           pac_position_x   DS.B 1 ; Coordonnée en X de la case où est Pacman
00301                           pac_position_y   DS.B 1 ;               Y
00302                           pac_sub_step_x   DS.B 1 ; Coordonnée en X dans la case (de -7 à +7)
00303                           pac_sub_step_y   DS.B 1 ;               Y
00304                           pac_direction_x  DS.B 1 ; Direction en X (-1, 0 ou 1)
00305                           pac_direction_y  DS.B 1 ;              Y
00306                           pac_next_dir_x   DS.B 1 ; Prochaine direction en X
00307                           pac_next_dir_y   DS.B 1 ;                        Y
00308                           pac_orientation  DS.B 1 ; voir plus haut
00309                           pac_anim         DS.B 1 ; animation de la bouche de Pacman
0030A                           
0030A                           ; Les variables des fantômes
0030A                           ghost_position_x  DS.B 4 ; Position en X des 4 fantômes
0030E                           ghost_position_y  DS.B 4 ;             Y
00312                           ghost_direction_x DS.B 4 ; Direction en X des 4 fantômes
00316                           ghost_direction_y DS.B 4 ; Direction en X des 4 fantômes
0031A                           ghost_sub_step_x  DS.B 4 ; Coordonnée en X dans la case (de -7 à +7)
0031E                           ghost_sub_step_y  DS.B 4 ;               Y
00322                           ghost_target_x    DS.B 4 ; La cible courante (en X) des 4 fantômes
00326                           ghost_target_y    DS.B 4 ;                       Y
0032A                           ghost_mode        DS.B 4 ; Mode de déplacement des fantômes (voir les constantes GM_*)
0032E                           ghost_timer       DS.B 4 ; Temps de transitions des modes de déplacement des fantômes
00332                           ghost_timer_high  DS.B 4 ; Partie hautes de ces temps
00336                           
00336                           ; Pilules
00336                           eaten_pills       DS.B 1 ; Nombre de pilules déjà mangées
00337                             ENDE
                                
                                  ENUM $0400 ; L'état actuel des pilules
00400                           pills                DS.B 4 * 31 ; Copie en RAM des positions des pilules (champ de bits)
0047C                           deleted_pill_address DS.B 2      ; Adresse dans la mémoire du PPU de la dernière pilule avalée
0047E                             ENDE
                                
                                ;; L'entête pour les émulateurs
      4E 45 53 1A                  DC.B "NES", $1a ; L'entête doit toujours commencer ainsi
      01                           DC.B 1          ; Le nombre de boitiers de 16 Ko de ROM CPU (1 ou 2)
      01                           DC.B 1          ; Le nombre de boitiers de 8 Ko de ROM PPU
      00                           DC.B 0          ; Direction de scrolling et type de cartouche
                                                   ; Ici, on veut le type le plus simple (0)
                                                   ;   avec un scrolling vertical (0 aussi)
      00 00 00 00 00 00 00 00..    DS.B 9, $00     ; Puis juste 9 zéros pour faire 16 en tout
                                
                                ;; Début du programme
                                 BASE $C000
0C000                           RESET:
0C000 A9 00                       LDA #0      ; Remise à zéro
0C002 85 01                       STA vbl_cnt ;   du compteur de VBL
0C004 8D 00 20                    STA $2000 ;   du Controle du PPU
0C007 8D 01 20                    STA $2001 ;   du Mask du PPU
0C00A 8D 10 40                    STA $4010   ; et de
0C00D A9 40                       LDA #$40    ;   tout
0C00F 8D 17 40                    STA $4017   ;     l'APU
0C012                           
0C012 A2 FF                       LDX #$ff    ; Initialise la pile à 255
0C014 9A                          TXS
0C015                           
0C015                           ;; On attend un peu que le PPU se réveille
0C015 2C 02 20                    BIT $2002
0C018 2C 02 20                  - BIT $2002 ; On boucle tant que le
0C01B 10 FB                       BPL -         ; PPU n'est pas prêt
0C01D                           
0C01D                           ;; Remise à zéro de toute la RAM
0C01D A9 00                       LDA #0       ; Place 0 dans A
0C01F AA                          TAX          ;   et dans X
0C020 95 00                     - STA $0000,X  ; Efface l'adresse   0 + X
0C022 9D 00 01                    STA $0100,X  ; Efface l'adresse 256 + X
0C025                             ; on n'efface pas $0200,X (voir plus bas)
0C025 9D 00 03                    STA $0300,X  ; Efface l'adresse 768 + X
0C028 9D 00 04                    STA $0400,X  ;   etc.
0C02B 9D 00 05                    STA $0500,X
0C02E 9D 00 06                    STA $0600,X
0C031 9D 00 07                    STA $0700,X
0C034 E8                          INX          ; Incrémente X
0C035 D0 E9                       BNE -        ; et boucle tant que X ne revient pas à 0
0C037                           
0C037                           ;; On initialise tout le segment "sprites" à 255
0C037 A9 FF                       LDA #255     ; X vaut déjà 0
0C039 9D 00 02                  - STA $0200,X  ; On place des 255
0C03C E8                          INX          ;   sur tout ce segment
0C03D D0 FA                       BNE -        ;     boucle tant que X ne revient pas à 0
0C03F                           
0C03F                           ;; On attend encore un peu le PPU, au cas où
0C03F AD 02 20                    LDA $2002
0C042                           
0C042                           ;; Chargement de la palette de couleurs
0C042 A9 3F                       LDA #$3F    ; On positionne le registre
0C044 8D 06 20                    STA $2006 ;   d'adresse du PPU
0C047 A9 00                       LDA #$00    ;   à la valeur $3F00
0C049 8D 06 20                    STA $2006
0C04C                           
0C04C A2 00                       LDX #0         ; Initialise X à 0
0C04E BD EA C8                  - LDA palette,X  ; On charge la Xième couleur
0C051 8D 07 20                    STA $2007    ;   pour l'envoyer au PPU
0C054 E8                          INX            ; On passe à la couleur suivante
0C055 E0 20                       CPX #32        ; Et ce, 32 fois
0C057 D0 F5                       BNE -          ; Boucle au - précédent
0C059                           
0C059                           ;; Effaçage des attributs
0C059 AD 02 20                    LDA $2002  ; On se resynchronise
0C05C A9 23                       LDA #$23       ; Le registre d'adresse PPU
0C05E 8D 06 20                    STA $2006    ;   est chargé avec la valeur
0C061 A9 C0                       LDA #$C0       ;   $23C0
0C063 8D 06 20                    STA $2006    ;   (attributs de la nametable 0)
0C066                           
0C066 A9 00                       LDA #0         ; Initialise A
0C068 AA                          TAX            ;   et X à zéro
0C069 8D 07 20                  - STA $2007    ;   0 est envoyé au PPU
0C06C E8                          INX            ; Et on boucle
0C06D E0 40                       CPX #64        ;   64 fois
0C06F D0 F8                       BNE -
0C071                           
0C071 A9 2B                       LDA #$2B       ; Le registre d'adresse PPU
0C073 8D 06 20                    STA $2006    ;   est chargé avec la valeur
0C076 A9 C0                       LDA #$C0       ;   $2BC0
0C078 8D 06 20                    STA $2006    ;   (attributs de la nametable 2)
0C07B                           
0C07B A9 00                       LDA #0         ; Initialise A
0C07D AA                          TAX            ;   et X à zéro
0C07E 8D 07 20                  - STA $2007    ;   0 est envoyé au PPU
0C081 E8                          INX            ; Et on boucle
0C082 E0 40                       CPX #64        ;   64 fois
0C084 D0 F8                       BNE -
0C086                           
0C086                             ;; Affichage du fond (murs)
0C086 AD 02 20                    LDA $2002  ; Resynchronisation
0C089 A9 20                       LDA #$20       ;   On copie maintenant
0C08B 8D 06 20                    STA $2006    ;     vers l'adresse $2000
0C08E A9 00                       LDA #$00
0C090 8D 06 20                    STA $2006
0C093                           
0C093                             ; On veut copier 30 lignes de 32 colonnes
0C093                             ; Soit 960 octets = 3 * 256 + 192
0C093 A2 00                       LDX #0      ; Copie des 256
0C095 BD 0A C9                  - LDA murs,x  ;  premiers octets
0C098 8D 07 20                    STA $2007 ;   depuis "murs"
0C09B E8                          INX         ; Après 256 incrémentations...
0C09C D0 F7                       BNE -       ;  X revient à 0
0C09E                           
0C09E BD 0A CA                  - LDA murs+256,x ; Copie des 256
0C0A1 8D 07 20                    STA $2007    ;   octets suivants
0C0A4 E8                          INX
0C0A5 D0 F7                       BNE -
0C0A7                           
0C0A7 BD 0A CB                  - LDA murs+512,x ; Puis encore 256 octets
0C0AA 8D 07 20                    STA $2007
0C0AD E8                          INX
0C0AE D0 F7                       BNE -
0C0B0                           
0C0B0 BD 0A CC                  - LDA murs+768,x ; Et Finalement les 192 derniers
0C0B3 8D 07 20                    STA $2007
0C0B6 E8                          INX
0C0B7 E0 C0                       CPX #192
0C0B9 D0 F5                       BNE -
0C0BB                           
0C0BB                           ; Il manque encore les 5 lignes du bas du labyrinthe
0C0BB                           ;   à partir de "murs2" vers l'adresse $2800 du PPU
0C0BB A9 28                       LDA #$28    ; Octet de poids fort
0C0BD 8D 06 20                    STA $2006
0C0C0 A9 00                       LDA #0      ; Puis celui de poids faible
0C0C2 8D 06 20                    STA $2006
0C0C5                           
0C0C5 A2 00                       LDX #0
0C0C7 BD CA CC                  - LDA murs2,x ; On prend les données depuis murs2
0C0CA 8D 07 20                    STA $2007
0C0CD E8                          INX
0C0CE E0 A0                       CPX #5 * 32
0C0D0 D0 F5                       BNE -
0C0D2                           
0C0D2 A9 28                       LDA #40           ; Initialisation du scrolling
0C0D4 85 03                       STA scroll_offset
0C0D6                           
0C0D6 2C 02 20                    BIT $2002 ; Resynchronisation
0C0D9 2C 02 20                  - BIT $2002 ; On attend une dernière fois
0C0DC 10 FB                       BPL -
0C0DE                           
0C0DE 20 06 C1                    JSR init_pac    ; Initialisation des variables de pacman
0C0E1 20 2B C1                    JSR init_ghosts ; Initialisation des variables des fantômes
0C0E4 A9 00                       LDA #0          ; Initialisation du
0C0E6 8D 36 03                    STA eaten_pills ;   nombre de pilules mangées
0C0E9                           
0C0E9                           ; Initialisation des pilules (pour pouvoir les effacer une par une de cette table)
0C0E9 A2 00                       LDX #0               ; On copie la table des pilules
0C0EB BD E6 CD                  - LDA starting_pills,x ;   depuis la ROM
0C0EE 9D 00 04                    STA pills,x          ;   vers la RAM
0C0F1 E8                          INX                  ;
0C0F2 E0 7C                       CPX #4 * 31          ; 124 octets à copier
0C0F4 D0 F5                       BNE -
0C0F6                           
0C0F6                           ;; Avant de rebrancher le PPU
0C0F6 A9 90                       LDA #%10010000 ; Réactivation, avec les tuiles de fond en $1000
0C0F8 8D 00 20                    STA $2000
0C0FB A9 1E                       LDA #%00011110 ; Sélection de l'affichage des tuiles et des sprites
0C0FD 8D 01 20                    STA $2001
0C100                           
0C100 20 D8 C8                    JSR rand_init  ; Initialisation du générateur de nombres pseudo-aléatoires
0C103                           
0C103 4C 6F C1                    JMP mainloop
0C106                           
0C106                           init_pac:
0C106 A9 0F                       LDA #15             ; On initialise la position
0C108 8D 00 03                    STA pac_position_x  ;   de Pacman à
0C10B A9 17                       LDA #23             ;   (15, 23)
0C10D 8D 01 03                    STA pac_position_y
0C110 A9 00                       LDA #0              ; Et tout le reste à 0
0C112 8D 04 03                    STA pac_direction_x
0C115 8D 05 03                    STA pac_direction_y
0C118 8D 02 03                    STA pac_sub_step_x
0C11B 8D 03 03                    STA pac_sub_step_y
0C11E 8D 06 03                    STA pac_next_dir_x
0C121 8D 07 03                    STA pac_next_dir_y
0C124 8D 08 03                    STA pac_orientation
0C127 8D 09 03                    STA pac_anim
0C12A 60                          RTS
0C12B                           
0C12B                             ; Initialisation des positions des fantômes
0C12B                           init_ghosts:
0C12B A2 00                       LDX #0
0C12D BD 62 CE                  - LDA ghost_default_values,X ; On prend les valeurs par défaut en ROM
0C130 9D 0A 03                    STA ghost_position_x,X     ;   pour initialiser les propriétés des fantômes en RAM
0C133 E8                          INX
0C134 E0 2C                       CPX #11 * 4                ; Il y a 11 propriétés
0C136 D0 F5                       BNE -
0C138 60                          RTS
0C139                           
0C139                           ;; La routine VBL
0C139                           VBL:
0C139 48                          PHA ; Sauvegarde de A sur la pile
0C13A                           
0C13A                             ; Envoi des 64 sprites par DMA
0C13A A9 00                       LDA #0       ; Poids faible d'abord
0C13C 8D 03 20                    STA $2003  ;
0C13F A9 02                       LDA #2       ; Puis le poids fort.
0C141 8D 14 40                    STA $4014
0C144                           
0C144 A9 01                       LDA #1            ; On indique à la partie principale
0C146 85 02                       STA vbl_flag      ;   que la VBL a eu lieu
0C148 E6 01                       INC vbl_cnt       ; Et On incrémente le compteur de VBL
0C14A                           
0C14A                             ; Effaçage de la pilule
0C14A AD 7C 04                    LDA deleted_pill_address   ; On efface la dernière
0C14D 8D 06 20                    STA $2006                ;  pilule mangée à chaque frame
0C150 AD 7D 04                    LDA deleted_pill_address+1 ; (plus facile à gérer ainsi)
0C153 8D 06 20                    STA $2006
0C156 A9 00                       LDA #0                     ; la tuile 0 contient juste du vide (noir)
0C158 8D 07 20                    STA $2007
0C15B                           
0C15B 2C 02 20                    BIT $2002     ; Resynchronisation au cas où...
0C15E A9 00                       LDA #0            ; On ne se décale pas du tout en X
0C160 8D 05 20                    STA $2005     ;
0C163 A5 03                       LDA scroll_offset ; Et la variable de décalage est
0C165 8D 05 20                    STA $2005     ;   utilisé comme scrolling vertical
0C168                           
0C168 A9 90                       LDA #%10010000 ; Réactivation, avec les tuiles de fond en $1000
0C16A 8D 00 20                    STA $2000
0C16D 68                          PLA ; Récupération de A
0C16E 40                          RTI
0C16F                           
0C16F                           ;; La boucle principale du programme
0C16F                           mainloop:
0C16F A5 02                     - LDA vbl_flag ; On attend que la VBL ait lieu
0C171 F0 FC                       BEQ -
0C173 A9 00                       LDA #0       ;  et on réinitialise le drapeau
0C175 85 02                       STA vbl_flag
0C177                           
0C177                             ; Gestion du JoyPad
0C177 A9 01                       LDA #1      ; On réinitialise la lecture du Joypad
0C179 8D 16 40                    STA $4016 ;   en écrivant un 1
0C17C A9 00                       LDA #0      ;     suivi d'un 0
0C17E 8D 16 40                    STA $4016 ;       dans cette adresse
0C181                           
0C181                             ; Ensuite, on peut lire l'état de chaque bouton :
0C181 AD 16 40                    LDA $4016 ; Lecture du bouton A (ignoré)
0C184 AD 16 40                    LDA $4016 ; Lecture du bouton B (ignoré)
0C187 AD 16 40                    LDA $4016 ; Lecture du bouton Select (ignoré)
0C18A AD 16 40                    LDA $4016 ; Lecture du bouton Start (ignoré)
0C18D                           
0C18D                             ; Test du bouton Up
0C18D AD 16 40                    LDA $4016        ; Lecture du bouton Up
0C190 29 01                       AND #1             ; S'il n'est pas pressé
0C192 F0 0A                       BEQ +              ;    On passe à la suite
0C194 A9 00                       LDA #0             ; Sinon, on enregistre l'envie
0C196 8D 06 03                    STA pac_next_dir_x ;    d'aller en haut :
0C199 A9 FF                       LDA #-1            ;     dx = 0, dy = -1
0C19B 8D 07 03                    STA pac_next_dir_y
0C19E                           +
0C19E                           
0C19E                             ; Test du bouton Down
0C19E AD 16 40                    LDA $4016        ; Lecture du bouton Up
0C1A1 29 01                       AND #1             ; S'il n'est pas pressé
0C1A3 F0 0A                       BEQ +              ;    On passe à la suite
0C1A5 A9 00                       LDA #0             ; Sinon, on enregistre l'envie
0C1A7 8D 06 03                    STA pac_next_dir_x ;    d'aller en bas :
0C1AA A9 01                       LDA #1             ;     dx = 0, dy = 1
0C1AC 8D 07 03                    STA pac_next_dir_y
0C1AF                           +
0C1AF                           
0C1AF                             ; Test du bouton Left
0C1AF AD 16 40                    LDA $4016        ; Lecture du bouton Left
0C1B2 29 01                       AND #1             ; S'il n'est pas pressé
0C1B4 F0 0A                       BEQ +              ;    On passe à la suite
0C1B6 A9 FF                       LDA #-1            ; Sinon, on enregistre l'envie
0C1B8 8D 06 03                    STA pac_next_dir_x ;    d'aller à gauche :
0C1BB A9 00                       LDA #0             ;     dx = -1, dy = 0
0C1BD 8D 07 03                    STA pac_next_dir_y
0C1C0                           +
0C1C0                           
0C1C0                             ; Test du bouton Right
0C1C0 AD 16 40                    LDA $4016        ; Lecture du bouton Right
0C1C3 29 01                       AND #1             ; S'il n'est pas pressé
0C1C5 F0 0A                       BEQ +              ;    On passe à la suite
0C1C7 A9 01                       LDA #1             ; Sinon, on enregistre l'envie
0C1C9 8D 06 03                    STA pac_next_dir_x ;    d'aller à droite :
0C1CC A9 00                       LDA #0             ;     dx = 1, dy = 0
0C1CE 8D 07 03                    STA pac_next_dir_y
0C1D1                           +
0C1D1                           
0C1D1 20 E3 C1                    JSR move_pacman          ; Déplacement du pacman
0C1D4 20 CF C3                    JSR update_scroll_offset ; Gestion du défilement vertical
0C1D7 20 AB C6                    JSR draw_pacman          ; Affichage de Pacman
0C1DA 20 FA C3                    JSR move_ghosts          ; Déplacement (Intelligence ?) des fantômes
0C1DD 20 70 C7                    JSR draw_ghosts          ; Affichage des 4 fantômes
0C1E0                             ; et on reboucle sans fin
0C1E0 4C 6F C1                    JMP mainloop
0C1E3                           
0C1E3                           ; Gestion du déplacement de Pacman
0C1E3                           move_pacman:
0C1E3 AD 04 03                    LDA pac_direction_x ; Si on ne bouge ni en X
0C1E6 0D 05 03                    ORA pac_direction_y ;   ni en Y,
0C1E9 F0 4A                       BEQ no_move         ;     on saute un bout de code
0C1EB                           
0C1EB EE 09 03                    INC pac_anim        ; On change l'animation du pacman
0C1EE                           
0C1EE                             ; Et on met à jour sa forme suivant la direction
0C1EE AD 04 03                    LDA pac_direction_x      ; Si Pacman ne va pas
0C1F1 C9 FF                       CMP #-1                  ;   vers la gauche,
0C1F3 D0 08                       BNE +                    ;   on passe à la suite
0C1F5 A2 00                       LDX #0  ; Sinon, on met à jour
0C1F7 8E 08 03                    STX pac_orientation      ;   la variable pac_orientation
0C1FA 4C 21 C2                    JMP end_shape            ;   et c'est terminé
0C1FD                           
0C1FD C9 01                     + CMP #1                   ; Même chose
0C1FF D0 08                       BNE +                    ;   pour
0C201 A2 01                       LDX #1 ;     la droite
0C203 8E 08 03                    STX pac_orientation
0C206 4C 21 C2                    JMP end_shape
0C209                           
0C209 AD 05 03                  + LDA pac_direction_y      ; Et verticalement,
0C20C C9 FF                       CMP #-1                  ; On fait le même test
0C20E D0 08                       BNE +                    ;   pour le haut...
0C210 A2 02                       LDX #2
0C212 8E 08 03                    STX pac_orientation
0C215 4C 21 C2                    JMP end_shape
0C218                           
0C218 C9 01                     + CMP #1                   ; ... et pour
0C21A D0 05                       BNE +                    ;       le bas
0C21C A2 03                       LDX #3
0C21E 8E 08 03                    STX pac_orientation
0C221                           +
0C221                           end_shape:
0C221                           
0C221                           ; Avancement du Pacman d'un pixel dans la direction courante :
0C221 AD 02 03                    LDA pac_sub_step_x  ; On avance la sous-position en x
0C224 18                          CLC                 ;   de -1, 0 ou +1
0C225 6D 04 03                    ADC pac_direction_x ;   suivant la direction actuelle
0C228 8D 02 03                    STA pac_sub_step_x
0C22B                           
0C22B AD 03 03                    LDA pac_sub_step_y  ; même chose en Y
0C22E 18                          CLC
0C22F 6D 05 03                    ADC pac_direction_y
0C232 8D 03 03                    STA pac_sub_step_y
0C235                           
0C235                           no_move:
0C235                             ; Vérification du cas où on est sur une nouvelle case
0C235 AD 02 03                    LDA pac_sub_step_x ; L'un de ces deux est null
0C238 0D 03 03                    ORA pac_sub_step_y ; Si en les additionnants...
0C23B 29 07                       AND #7             ;   on a un multiple de 8
0C23D F0 01                       BEQ +              ; alors on passe à la suite
0C23F 60                          RTS                ; Sinon, on a fini de traiter les mouvements
0C240                           +
0C240 AD 00 03                    LDA pac_position_x  ; On avance alors la position
0C243 18                          CLC                 ;  (en nombre de cases) en X
0C244 6D 04 03                    ADC pac_direction_x ;  de -1, 0 ou +1
0C247 8D 00 03                    STA pac_position_x  ;  suivant la direction actuelle
0C24A                           
0C24A AD 01 03                    LDA pac_position_y  ; Et on fait la même chose
0C24D 18                          CLC                 ;   en Y
0C24E 6D 05 03                    ADC pac_direction_y
0C251 8D 01 03                    STA pac_position_y
0C254                           
0C254                             ; Et On remet à 0 les sous-positions :
0C254 A9 00                       LDA #0
0C256 8D 02 03                    STA pac_sub_step_x
0C259 8D 03 03                    STA pac_sub_step_y
0C25C                           
0C25C 20 E0 C2                    JSR remove_pill
0C25F                           ; On vérifie si on n'essaie pas de foncer dans un mur
0C25F AD 00 03                    LDA pac_position_x ; param_x = pac_position_x + pac_next_dir_x
0C262 18                          CLC
0C263 6D 06 03                    ADC pac_next_dir_x
0C266 85 08                       STA param_x
0C268                           
0C268 AD 01 03                    LDA pac_position_y ; param_y = pac_position_y + pac_next_dir_y
0C26B 18                          CLC
0C26C 6D 07 03                    ADC pac_next_dir_y
0C26F 85 09                       STA param_y
0C271                           
0C271 20 B0 C3                    JSR check_for_wall     ; Si (param_x, param_y) est un mur
0C274 D0 1C                       BNE dont_set_direction ;   on évite d'y aller !
0C276                           
0C276 A5 09                       LDA param_y            ; On test spécifiquement
0C278 C9 0C                       CMP #12                ;  la barrière de l'enclos
0C27A D0 0A                       BNE set_direction      ;  aux positions (15,12) et (16,12)
0C27C A5 08                       LDA param_x            ;  car Pacman n'as pas le droit
0C27E C9 0F                       CMP #15                ;  d'aller là.
0C280 F0 10                       BEQ dont_set_direction
0C282 C9 10                       CMP #16
0C284 F0 0C                       BEQ dont_set_direction
0C286                           
0C286                           set_direction:
0C286                             ; S'il n'y a pas de mur, on peut y aller
0C286 AD 06 03                    LDA pac_next_dir_x  ; on copie la prochaine
0C289 8D 04 03                    STA pac_direction_x ;  direction souhaitée
0C28C AD 07 03                    LDA pac_next_dir_y  ;  dans la nouvelle
0C28F 8D 05 03                    STA pac_direction_y ;  direction courante
0C292                           
0C292                           dont_set_direction:
0C292                             ; On continue dans la même direction,
0C292                             ; mais on vérifie si on ne fonce pas dans un mur
0C292 AD 00 03                    LDA pac_position_x ; param_x = pac_position_x + pac_direction_x
0C295 18                          CLC
0C296 6D 04 03                    ADC pac_direction_x
0C299 85 08                       STA param_x
0C29B                           
0C29B AD 01 03                    LDA pac_position_y ; param_y = pac_position_y + pac_direction_y
0C29E 18                          CLC
0C29F 6D 05 03                    ADC pac_direction_y
0C2A2 85 09                       STA param_y
0C2A4                           
0C2A4 20 B0 C3                    JSR check_for_wall       ; S'il n'y a pas de mur,
0C2A7 F0 08                       BEQ dont_reset_direction ;   tout va bien et on continue
0C2A9                           
0C2A9                           reset_direction:
0C2A9 A9 00                       LDA #0                   ; Sinon, on s'arrête
0C2AB 8D 04 03                    STA pac_direction_x      ;   En mettant tout à zéro
0C2AE 8D 05 03                    STA pac_direction_y
0C2B1                           
0C2B1                           dont_reset_direction:
0C2B1                             ;; Prise en compte du tunnel
0C2B1                             ; Vers la gauche
0C2B1 AD 00 03                    LDA pac_position_x  ; Si on est à la position X = 2
0C2B4 C9 02                       CMP #2
0C2B6 D0 0C                       BNE no_left_tunnel
0C2B8 AD 04 03                    LDA pac_direction_x ; Et qu'on va vers la gauche,
0C2BB C9 FF                       CMP #-1
0C2BD D0 05                       BNE no_left_tunnel
0C2BF A9 1D                       LDA #29             ; On se téléporte en X = 29
0C2C1 8D 00 03                    STA pac_position_x
0C2C4                           no_left_tunnel:
0C2C4                           
0C2C4                             ; Vers la droite
0C2C4 AD 00 03                    LDA pac_position_x  ; Si on est à la position X = 29
0C2C7 C9 1D                       CMP #29
0C2C9 D0 0C                       BNE no_right_tunnel
0C2CB AD 04 03                    LDA pac_direction_x ; Et qu'on va vers la droite,
0C2CE C9 01                       CMP #1
0C2D0 D0 05                       BNE no_right_tunnel
0C2D2 A9 02                       LDA #2              ; On se téléporte en X = 2
0C2D4 8D 00 03                    STA pac_position_x
0C2D7                           no_right_tunnel:
0C2D7                           
0C2D7 60                          RTS
0C2D8                           
0C2D8                           
0C2D8                           ; Table de conversion entre un numéro de bit et une puissance de 2
0C2D8                           bits:
0C2D8 80                         DC.B %10000000
0C2D9 40                         DC.B %01000000
0C2DA 20                         DC.B %00100000
0C2DB 10                         DC.B %00010000
0C2DC 08                         DC.B %00001000
0C2DD 04                         DC.B %00000100
0C2DE 02                         DC.B %00000010
0C2DF 01                         DC.B %00000001
0C2E0                           
0C2E0                           ; Gestion de tout ce qu'il se passe quand on avale éventuellement une pilule.
0C2E0                           current_mask EQU tmp_var+1 ; renommage de cette variable pour cette fonction (plus parlant)
0C2E0                           remove_pill:
0C2E0                             ; on efface la pilule dans l'écran en renseignant deleted_pill_address
0C2E0                             ; qui est l'adresse dans la RAM du PPU de la pilule qu'on efface sans arrêt
0C2E0 AD 01 03                    LDA pac_position_y  ; On commence par déterminer si on
0C2E3 C9 1C                       CMP #28             ;  est dans la partie haute ou basse de l'écran
0C2E5 30 05                       BMI +               ; Dans la partie basse,
0C2E7 A9 28                       LDA #$28            ;   l'adresse commence par $28..
0C2E9 4C F5 C2                    JMP ++
0C2EC                           +
0C2EC 18                          CLC                 ; Dans la partie haute,
0C2ED 69 02                       ADC #2              ; On prend en compte les deux lignes vides
0C2EF 4A                          LSR                 ; avant de diviser la position par 8
0C2F0 4A                          LSR                 ;  en divisant 3 fois par 2
0C2F1 4A                          LSR                 ; pour avoir l'octet de poids fort de l'adresse
0C2F2 18                          CLC                 ; (les lignes font 32 octets et 32*8 = 256)
0C2F3 69 20                       ADC #$20            ; Ajout de la base, l'adresse commencera alors par $20.. $21.., $22.. ou $23..
0C2F5                           ++
0C2F5 8D 7C 04                    STA deleted_pill_address
0C2F8                           
0C2F8                             ; Calcul de l'octet de poids faible de la position de la pilule à effacer
0C2F8 AD 01 03                    LDA pac_position_y  ; Si on est dans la partie bassee de l'écran,
0C2FB C9 1C                       CMP #28             ;  (au dessous de la 28e ligne)
0C2FD 30 06                       BMI +
0C2FF 38                          SEC
0C300 E9 1C                       SBC #28             ; on enlève 28
0C302 4C 08 C3                    JMP ++
0C305                           +
0C305 18                          CLC
0C306 69 02                       ADC #2              ; Sinon on ajoute 2 (toujours pour les deux lignes vides...)
0C308                           ++
0C308 0A                          ASL                 ; Et on multiplie par 32
0C309 0A                          ASL                 ; en multipliant
0C30A 0A                          ASL                 ;  5 fois de suite par 2
0C30B 0A                          ASL
0C30C 0A                          ASL
0C30D 18                          CLC
0C30E 6D 00 03                    ADC pac_position_x  ; avant d'ajouter la position de Pacman en X
0C311 8D 7D 04                    STA deleted_pill_address + 1
0C314                           
0C314                             ; Maintenant, on teste si la pilule à cette position a déjà été mangée ou pas
0C314 AD 00 03                    LDA pac_position_x  ; On commence par récupérer les 3 bits de la position en X
0C317 29 07                       AND #7              ; (x modulo 8)
0C319 AA                          TAX                 ; et on convertit ça en un bit, pour pouvoir tester facilement
0C31A BD D8 C2                    LDA bits,x
0C31D 85 0B                       STA tmp_var+1    ; current_mask contient alors %01000000 ou %00010000 par exemple.
0C31F AD 00 03                    LDA pac_position_x  ; Puis on cherche quel octet de la table des pilules
0C322 4A                          LSR                 ; correspond à la position actuelle
0C323 4A                          LSR                 ; en divisant la position X par 8 (3 divisions par 2)
0C324 4A                          LSR
0C325 85 0A                       STA tmp_var
0C327 AD 01 03                    LDA pac_position_y  ; Et en multipliant Y par 4 (4 octets (=32 bits) par ligne)
0C32A 0A                          ASL
0C32B 0A                          ASL
0C32C 18                          CLC
0C32D 65 0A                       ADC tmp_var         ; tmp_var = Y / 4 + X * 8
0C32F AA                          TAX
0C330 BD 00 04                    LDA pills,x
0C333 25 0B                       AND tmp_var+1    ; et on test s'il y a un 1 ou pas à cette position.
0C335 D0 01                       BNE +               ; Si ce n'est pas le cas, la pilule a déjà été mangée,
0C337 60                          RTS                 ;  et on a terminé de traiter tout ça.
0C338                           +
0C338                             ; On met à jour la table pour enlever ce "1" qu'on vient de trouver
0C338 A5 0B                       LDA tmp_var+1    ; On inverse le mask
0C33A 49 FF                       EOR #$ff            ;  pour avoir des 1 partout sauf à l'emplacement de la pilule
0C33C 85 0B                       STA tmp_var+1
0C33E BD 00 04                    LDA pills,x         ; Et on utilise cette valeur pour
0C341 25 0B                       AND tmp_var+1    ;  n'effacer éventuellement que ce bit.
0C343 9D 00 04                    STA pills,x
0C346                           
0C346                             ; Mise à jour du nombre pilules mangées
0C346 EE 36 03                    INC eaten_pills     ; Une de plus !
0C349 AD 36 03                    LDA eaten_pills     ; Si on les a toutes mangées,
0C34C C9 F4                     - CMP #244 ; Pour l'instant, on stoppe le programme en bouclant sur place
0C34E F0 FC                       BEQ -               ; Mais il faudrait passer au niveau suivant !
0C350                           
0C350                             ; Traitement des Pac-gommes
0C350 A9 00                       LDA #0              ; Les pac-gommes sont aux coordonnées
0C352 85 0A                       STA tmp_var         ; (3,3), (3,23), (28,3) et (28,23)
0C354 AD 00 03                    LDA pac_position_x  ; On commence par tester
0C357 C9 03                       CMP #3              ;   la position en X
0C359 D0 02                       BNE +               ;   et on si on est en 3
0C35B E6 0A                       INC tmp_var
0C35D C9 1C                     + CMP #28             ;   ou en 28,
0C35F D0 02                       BNE +
0C361 E6 0A                       INC tmp_var         ; On ajoute 1 à tmp_var
0C363 AD 01 03                  + LDA pac_position_y  ; Et en Y,
0C366 C9 03                       CMP #3              ;   si on est en 3
0C368 D0 04                       BNE +
0C36A E6 0A                       INC tmp_var
0C36C E6 0A                       INC tmp_var
0C36E C9 17                     + CMP #23             ;   ou en 23,
0C370 D0 04                       BNE +
0C372 E6 0A                       INC tmp_var         ; On ajoute 2 à tmp_var
0C374 E6 0A                       INC tmp_var
0C376 A5 0A                     + LDA tmp_var
0C378 C9 03                       CMP #3              ; Si tmp_var vaut 3, c'est qu'on ajouté 1 puis 2, on est sur une pac-gomme !
0C37A D0 2E                       BNE +
0C37C A9 02                       LDA #2        ; Les 4 fantômes passent alors dans le mode effrayé
0C37E 8D 2A 03                    STA ghost_mode
0C381 8D 2B 03                    STA ghost_mode+1
0C384 8D 2C 03                    STA ghost_mode+2
0C387 8D 2D 03                    STA ghost_mode+3
0C38A                           
0C38A A9 03                       LDA #3 ; Mise en place du timer du mode GM_FRIGHTENED
0C38C 8D 32 03                    STA ghost_timer_high       ;   pour les 4 fantômes
0C38F 8D 33 03                    STA ghost_timer_high + 1
0C392 8D 34 03                    STA ghost_timer_high + 2
0C395 8D 35 03                    STA ghost_timer_high + 3
0C398 A9 0A                       LDA #10
0C39A 8D 2E 03                    STA ghost_timer
0C39D 8D 2F 03                    STA ghost_timer + 1
0C3A0 8D 30 03                    STA ghost_timer + 2
0C3A3 8D 31 03                    STA ghost_timer + 3
0C3A6                           
0C3A6 20 AE C3                    JSR inc_score_big_pill  ; Et on augmente le score en fonction
0C3A9 60                          RTS
0C3AA                           +
0C3AA 20 AF C3                    JSR inc_score_pill      ; Sinon, on augmente juste le score pour la pilule avalée.
0C3AD 60                          RTS
0C3AE                           
0C3AE                           inc_score_big_pill:
0C3AE                             ; À remplir pour augmenter le score quand on mange une pac-gomme
0C3AE 60                          RTS
0C3AF                           inc_score_pill:
0C3AF                             ; À remplir pour augmenter le score quand on mange une pilule
0C3AF 60                          RTS
0C3B0                           
0C3B0                           ; Teste si la case (param_x, param_y) est occupée par un mur.
0C3B0                           ; Après un appel à cette fonction, on pourra utiliser
0C3B0                           ; BNE ou BEQ pour gérer les cas "mur" ou "pas de mur"
0C3B0                           check_for_wall:
0C3B0 A5 09                       LDA param_y ; on multiplie param_y par 4
0C3B2 0A                          ASL
0C3B3 0A                          ASL
0C3B4 85 0A                       STA tmp_var ; tmp_var = Y * 4
0C3B6                           
0C3B6 A5 08                       LDA param_x ; on divise param_x par 8
0C3B8 4A                          LSR
0C3B9 4A                          LSR
0C3BA 4A                          LSR
0C3BB 18                          CLC
0C3BC 65 0A                       ADC tmp_var ; tmp_var = Y * 4 + X / 8
0C3BE AA                          TAX
0C3BF BD 6A CD                    LDA wall_mask_8bit,X ; On récupère le bon octet
0C3C2 85 0A                       STA tmp_var          ; de la table des murs
0C3C4                           
0C3C4 A5 08                       LDA param_x  ; Et la coordonnée en X modulo 8
0C3C6 29 07                       AND #7       ;   nous donne le bit à tester
0C3C8 AA                          TAX
0C3C9 BD D8 C2                    LDA bits,X
0C3CC 25 0A                       AND tmp_var  ; Positionne le flag Z s'il n'y a pas de mur.
0C3CE 60                          RTS
0C3CF                           
0C3CF                           ; Mise à jour du défilement vertical
0C3CF                           update_scroll_offset:
0C3CF AD 01 03                    LDA pac_position_y ; Si on est à en dessous
0C3D2 C9 12                       CMP #18            ;   de la ligne 18,
0C3D4 30 05                       BMI +              ;   on met le défilement
0C3D6 A9 28                       LDA #40            ;   à 40 (valeur maximale)
0C3D8 85 03                       STA scroll_offset
0C3DA 60                          RTS
0C3DB                           
0C3DB C9 05                     + CMP #5             ; Au dessus de la ligne 5
0C3DD 10 05                       BPL +              ;   le défilement est nul
0C3DF A9 00                       LDA #0
0C3E1 85 03                       STA scroll_offset
0C3E3 60                          RTS
0C3E4                           
0C3E4 0A                        + ASL                ; Entre les deux, on calcule
0C3E5 0A                          ASL                ;   la position de Pacman au
0C3E6 0A                          ASL                ;   pixel près
0C3E7 18                          CLC                ;   8 * position + sub_step
0C3E8 6D 03 03                    ADC pac_sub_step_y ; Et on utilise cette position
0C3EB E9 28                       SBC #40            ;  en respectant les deux bornes
0C3ED 10 02                       BPL +              ;  0 et 40
0C3EF A9 00                       LDA #0             ;  comme valeur de défilement
0C3F1 C9 28                     + CMP #40
0C3F3 30 02                       BMI +
0C3F5 A9 28                       LDA #40
0C3F7 85 03                     + STA scroll_offset
0C3F9 60                          RTS
0C3FA                           
0C3FA                           ; Gestion des déplacements des fantômes
0C3FA                           move_ghosts:
0C3FA A2 00                       LDX #0
0C3FC 86 14                       STX ghost_current       ; On va avoir le même code pour chaque fantôme (4 tour de boucle)
0C3FE                           move_ghosts_loop:
0C3FE A6 14                       LDX ghost_current
0C400 20 B6 C5                    JSR update_mode         ; On vérifie si on doit changer de mode de déplacement
0C403 20 67 C6                    JSR set_target          ; Mise à jour de la cible de ce fantôme
0C406 BD 2A 03                    LDA ghost_mode,X        ; Si le fantôme est en mode
0C409 C9 05                       CMP #5         ;   WAITING, c'est qu'il ne bouge pas,
0C40B D0 03                       BNE +
0C40D 4C 38 C5                    JMP move_ghosts_next    ;   on passe alors directement au fantôme suivant
0C410                           +
0C410 18                          CLC
0C411 BD 1A 03                    LDA ghost_sub_step_x,X  ; Comme pour Pacman, on commence par avancer à l'intérieur d'une case
0C414 7D 12 03                    ADC ghost_direction_x,X ; En X
0C417 9D 1A 03                    STA ghost_sub_step_x,X
0C41A 18                          CLC
0C41B BD 1E 03                    LDA ghost_sub_step_y,X
0C41E 7D 16 03                    ADC ghost_direction_y,X ; Ou en Y
0C421 9D 1E 03                    STA ghost_sub_step_y,X
0C424                           
0C424                             ; Vérifie si on est sur une "case pleine"
0C424 1D 1A 03                    ORA ghost_sub_step_x,X  ; Si on est toujours entre deux cases,
0C427 29 07                       AND #7
0C429 F0 03                       BEQ +
0C42B 4C 38 C5                    JMP move_ghosts_next    ;  ... on passe directement au fantôme suivant
0C42E                           
0C42E                           + ; Traitement des "cases pleines"
0C42E A9 00                       LDA #0                  ; On remet à zéro les sous-positions
0C430 9D 1A 03                    STA ghost_sub_step_x,X  ;   en X
0C433 9D 1E 03                    STA ghost_sub_step_y,X  ;   et en Y
0C436                           
0C436 18                          CLC
0C437 BD 0A 03                    LDA ghost_position_x,X  ; Et on avance d'une case dans la direction actuelle
0C43A 7D 12 03                    ADC ghost_direction_x,X ;   en X
0C43D 9D 0A 03                    STA ghost_position_x,X
0C440 18                          CLC
0C441 BD 0E 03                    LDA ghost_position_y,X
0C444 7D 16 03                    ADC ghost_direction_y,X ;   et en Y
0C447 9D 0E 03                    STA ghost_position_y,X
0C44A                           
0C44A                           ; Choix de la nouvelle direction,
0C44A                           ; Implémentation d'une petite intelligence des fantômes
0C44A A9 04                       LDA #4                               ; Initialisation de l'index de direction à 4
0C44C 85 16                       STA ghost_direction_min_index        ;   qui est une direction inexistante (plus facile pour débugger)
0C44E A9 2A                       LDA #42                              ; Initialisation de la distance la plus courte entre une position
0C450 85 1F                       STA ghost_distance_min_to_target     ;   du fantôme et sa cible à une grande valeur (42 * 257)
0C452 85 20                       STA ghost_distance_min_to_target + 1 ;   pour être sûr d'en trouver une plus petite
0C454                           
0C454 A9 00                       LDA #0                               ; On boucle sur les quatre
0C456 85 15                       STA ghost_direction_index            ;   directions possibles
0C458                           ghost_move_direction_loop:
0C458 A6 14                       LDX ghost_current
0C45A A4 15                       LDY ghost_direction_index
0C45C                           
0C45C BD 0A 03                    LDA ghost_position_x,X               ; Calcul de la position du fantôme s'il prenait cette direction
0C45F 18                          CLC
0C460 79 6C C5                    ADC direction_table_x,Y
0C463 85 17                       STA ghost_new_position_x             ; On garde cette nouvelle position dans ghost_new_position_[xy]
0C465 85 08                       STA param_x                          ; et dans param_x/param_y
0C467                           
0C467 BD 0E 03                    LDA ghost_position_y,X
0C46A 18                          CLC
0C46B 79 70 C5                    ADC direction_table_y,Y
0C46E 85 18                       STA ghost_new_position_y
0C470 85 09                       STA param_y
0C472 20 B0 C3                    JSR check_for_wall                   ; Teste si la nouvelle position est un mur
0C475 F0 03                       BEQ +                                ; Si c'est le cas, cette direction n'est pas désirable,
0C477 4C 1D C5                    JMP ghost_move_direction_next        ;   et on passe à la suivante.
0C47A                           +
0C47A                             ; Test de la porte de l'enclos
0C47A A6 14                       LDX ghost_current                    ; La barrière de l'enclos : les cases (15,12) et (16,12)
0C47C BD 2A 03                    LDA ghost_mode,X                     ;   sont spéciales, les fantômes ne peuvent la franchir
0C47F C9 04                       CMP #4                       ;   que pour sortir, s'ils sont dedans...
0C481 F0 1A                       BEQ ++
0C483 C9 03                       CMP #3                        ;   ou pour rentrer mais uniquement quand ils se sont faits mangés
0C485 F0 16                       BEQ ++
0C487 A5 09                       LDA param_y
0C489 C9 0C                       CMP #12
0C48B D0 10                       BNE ++
0C48D A5 08                       LDA param_x
0C48F C9 0F                       CMP #15
0C491 D0 03                       BNE +
0C493 4C 1D C5                    JMP ghost_move_direction_next        ; Sinon, on passe directement à la direction suivante.
0C496                           +
0C496 C9 10                       CMP #16
0C498 D0 03                       BNE +
0C49A 4C 1D C5                    JMP ghost_move_direction_next
0C49D                           +
0C49D                           ++
0C49D A6 14                       LDX ghost_current
0C49F                             ; On va pas dans l'mur, continuons!
0C49F                             ; Vérification des demi-tours
0C49F BD 12 03                    LDA ghost_direction_x,X        ; Si, en additionnant la direction actuelle
0C4A2 18                          CLC
0C4A3 79 6C C5                    ADC direction_table_x,Y        ;   et la direction testée, on trouve 0
0C4A6 D0 0C                       BNE ghost_move_no_u_turn       ;   en X
0C4A8 BD 16 03                    LDA ghost_direction_y,X
0C4AB 18                          CLC
0C4AC 79 70 C5                    ADC direction_table_y,Y
0C4AF D0 03                       BNE ghost_move_no_u_turn       ;   et en Y, c'est qu'on essaie de faire demi-tour
0C4B1 4C 1D C5                    JMP ghost_move_direction_next  ;   ce qui est interdit pour les fantômes
0C4B4                           ghost_move_no_u_turn:
0C4B4                           
0C4B4 BD 2A 03                    LDA ghost_mode,X               ; Si le fantôme est effrayé,
0C4B7 C9 02                       CMP #2
0C4B9 D0 0F                       BNE +
0C4BB 20 DD C8                    JSR rand                       ; Il erre au hasard.
0C4BE 85 1D                       STA ghost_distance_to_target
0C4C0 20 DD C8                    JSR rand
0C4C3 29 1F                       AND #31
0C4C5 85 1E                       STA ghost_distance_to_target + 1 ; et la distance calculée devient aléatoire
0C4C7 4C 07 C5                    JMP move_ghosts_test_distance    ; puis on passe à la suite
0C4CA                           +
0C4CA                             ; Sinon, on calcule vraiment la distance |x|*|x| + |y|*|y|
0C4CA                             ; D'abord, |x|
0C4CA BD 22 03                    LDA ghost_target_x,X      ; On calcule la différence entre la cible
0C4CD 38                          SEC
0C4CE E5 17                       SBC ghost_new_position_x  ;   et la position
0C4D0 10 05                       BPL +                     ;   et si c'est négatif,
0C4D2 49 FF                       EOR #$ff                  ;   on change le signe (complément à 1
0C4D4 18                          CLC                       ;
0C4D5 69 01                       ADC #1                    ;                       plus 1)
0C4D7                           + ; puis |x|*|x|
0C4D7 A8                          TAY
0C4D8 B9 74 C5                    LDA square_table_low,Y           ; On élève ensuite cette valeur au carré
0C4DB 85 19                       STA ghost_distance_x_to_target   ;   en utilisant la table des carrés
0C4DD B9 95 C5                    LDA square_table_high,Y          ;   qui est sur deux octets (les valeurs dépassent souvent 256)
0C4E0 85 1A                       STA ghost_distance_x_to_target+1
0C4E2                             ; et |y|
0C4E2 BD 26 03                    LDA ghost_target_y,X             ; Même chose en y
0C4E5 38                          SEC
0C4E6 E5 18                       SBC ghost_new_position_y         ; Différence entre position et cible
0C4E8 10 05                       BPL +
0C4EA 49 FF                       EOR #$ff                         ; Changement de signe éventuel
0C4EC 18                          CLC
0C4ED 69 01                       ADC #1
0C4EF                           + ; maintenant |y|*|y|
0C4EF A8                          TAY
0C4F0 B9 74 C5                    LDA square_table_low,Y           ; Mise au carré
0C4F3 85 1B                       STA ghost_distance_y_to_target
0C4F5 B9 95 C5                    LDA square_table_high,Y
0C4F8 85 1C                       STA ghost_distance_y_to_target+1
0C4FA                           
0C4FA                             ; |x|*|x| + |y|*|y|
0C4FA 18                          CLC
0C4FB A5 19                       LDA ghost_distance_x_to_target   ; On additionne les carrés en X et en Y
0C4FD 65 1B                       ADC ghost_distance_y_to_target
0C4FF 85 1D                       STA ghost_distance_to_target
0C501 A5 1A                       LDA ghost_distance_x_to_target+1
0C503 65 1C                       ADC ghost_distance_y_to_target+1
0C505 85 1E                       STA ghost_distance_to_target+1   ; Pour avoir le carré de la distance euclidienne
0C507                           
0C507                           move_ghosts_test_distance:
0C507                             ; Compare avec la distance mini
0C507 A5 1D                       LDA ghost_distance_to_target       ; Si cette distance est plus petite
0C509 C5 1F                       CMP ghost_distance_min_to_target   ;  que la plus petite distance actuellement...
0C50B A5 1E                       LDA ghost_distance_to_target+1
0C50D E5 20                       SBC ghost_distance_min_to_target+1
0C50F B0 0C                       BCS +
0C511 A5 15                       LDA ghost_direction_index          ; On se souvient de l'indice de la direction
0C513 85 16                       STA ghost_direction_min_index      ;   qui a produit cette distance
0C515 A5 1D                       LDA ghost_distance_to_target       ; Et on met à jour la distance mini.
0C517 85 1F                       STA ghost_distance_min_to_target
0C519 A5 1E                       LDA ghost_distance_to_target+1
0C51B 85 20                       STA ghost_distance_min_to_target+1
0C51D                           +
0C51D                           ghost_move_direction_next:
0C51D E6 15                       INC ghost_direction_index          ; Et on passe à la direction suivante
0C51F A5 15                       LDA ghost_direction_index
0C521 C9 04                       CMP #4                             ; Jusqu'à avoir fait le tour des 4 directions
0C523 F0 03                       BEQ +
0C525 4C 58 C4                    JMP ghost_move_direction_loop
0C528                           +
0C528 A6 14                       LDX ghost_current                  ; Et on utilise tout cela
0C52A A4 16                       LDY ghost_direction_min_index      ;   pour mettre à jour la nouvelle direction
0C52C B9 6C C5                    LDA direction_table_x,Y            ;   du fantôme
0C52F 9D 12 03                    STA ghost_direction_x,X
0C532 B9 70 C5                    LDA direction_table_y,Y
0C535 9D 16 03                    STA ghost_direction_y,X
0C538                           
0C538                           move_ghosts_next:
0C538                             ; Et juste avant de passer au fantôme suivant...
0C538 A6 14                       LDX ghost_current
0C53A                             ;; Prise en compte du tunnel pour les fantômes
0C53A                             ; Vers la gauche
0C53A BD 0A 03                    LDA ghost_position_x,X  ; Si on est à la position X = 1
0C53D C9 01                       CMP #1
0C53F D0 0C                       BNE ghost_no_left_tunnel
0C541 BD 12 03                    LDA ghost_direction_x,X ; Et qu'on va vers la gauche,
0C544 C9 FF                       CMP #-1
0C546 D0 05                       BNE ghost_no_left_tunnel
0C548 A9 1E                       LDA #30             ; On se téléporte en X = 30
0C54A 9D 0A 03                    STA ghost_position_x,X
0C54D                           ghost_no_left_tunnel:
0C54D                           
0C54D                             ; Vers la droite
0C54D BD 0A 03                    LDA ghost_position_x,X  ; Si on est à la position X = 30
0C550 C9 1E                       CMP #30
0C552 D0 0C                       BNE ghost_no_right_tunnel
0C554 BD 12 03                    LDA ghost_direction_x,X ; Et qu'on va vers la droite,
0C557 C9 01                       CMP #1
0C559 D0 05                       BNE ghost_no_right_tunnel
0C55B A9 01                       LDA #1              ; On se téléporte en X = 1
0C55D 9D 0A 03                    STA ghost_position_x,X
0C560                           ghost_no_right_tunnel:
0C560                           
0C560 E6 14                       INC ghost_current     ; Et on boucle sur les 4 fantômes.
0C562 A5 14                       LDA ghost_current
0C564 C9 04                       CMP #4
0C566 F0 03                       BEQ +
0C568 4C FE C3                    JMP move_ghosts_loop
0C56B                           +
0C56B 60                          RTS
0C56C                           
0C56C                           ; Les tables des directions
0C56C                           ; Dans l'ordre : gauche, droite, haut, bas.
0C56C                           direction_table_x:
0C56C FF 01 00 00                 DC.B -1, 1, 0, 0
0C570                           direction_table_y:
0C570 00 00 FF 01                 DC.B 0, 0, -1, 1
0C574                           
0C574                           ; Table des carrés pour les calculs des distances
0C574                           square_table_low: ; Octets de poids forts :
0C574 00 01 04 09 10 19 24 31..   DL 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961, 1024
0C595                           
0C595                           square_table_high: ; Octets de poids faibles
0C595 00 00 00 00 00 00 00 00..   DH 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961, 1024
0C5B6                           
0C5B6                           
0C5B6                           ; Mise à jour du mode de déplacement d'un fantôme
0C5B6                           update_mode:
0C5B6 BD 2A 03                    LDA ghost_mode,X             ; Suivant le mode actuel pour ce fantôme
0C5B9 20 C3 C8                    JSR on_goto                  ; On saute à telle ou telle sous-routine
0C5BC C8 C5                       DC.W update_mode_corner
0C5BE E2 C5                       DC.W update_mode_chase
0C5C0 FC C5                       DC.W update_mode_frightened
0C5C2 2C C6                       DC.W update_mode_eaten
0C5C4 45 C6                       DC.W update_mode_in_pen
0C5C6 5C C6                       DC.W update_mode_waiting
0C5C8                           
0C5C8                           ; Traitement du mode coins
0C5C8                           update_mode_corner:
0C5C8 DE 2E 03                    DEC ghost_timer,X       ; On décrémente le timer correspondant
0C5CB D0 14                       BNE +
0C5CD DE 32 03                    DEC ghost_timer_high,X  ;   qui est sur 2 octets
0C5D0 D0 0F                       BNE +                   ; Si on arrive à zéro,
0C5D2 A9 01                       LDA #1           ; On passe en mode pourchasse de Pacman
0C5D4 9D 2A 03                    STA ghost_mode,X
0C5D7 A9 07                       LDA #7   ; Et on réinitialise le timer
0C5D9 9D 32 03                    STA ghost_timer_high,X
0C5DC A9 17                       LDA #23
0C5DE 9D 2E 03                    STA ghost_timer,X
0C5E1 60                        + RTS
0C5E2                           
0C5E2                           ; Traitement du mode pourchasse
0C5E2                           update_mode_chase:
0C5E2 DE 2E 03                    DEC ghost_timer,X      ; On décrémente le timer correspondant
0C5E5 D0 14                       BNE +
0C5E7 DE 32 03                    DEC ghost_timer_high,X ;   qui est sur 2 octets
0C5EA D0 0F                       BNE +                  ; Si on arrive à zéro,
0C5EC A9 00                       LDA #0         ; On passe en mode coin
0C5EE 9D 2A 03                    STA ghost_mode,X
0C5F1 A9 08                       LDA #8 ; Et on réinitialise le timer
0C5F3 9D 32 03                    STA ghost_timer_high,X
0C5F6 A9 2F                       LDA #47
0C5F8 9D 2E 03                    STA ghost_timer,X
0C5FB 60                        + RTS
0C5FC                           
0C5FC                           ; Traitement du mode "effrayé" (après une pac-gomme)
0C5FC                           update_mode_frightened:
0C5FC BD 0A 03                    LDA ghost_position_x,X  ; On vérifie si on est sur la même case
0C5FF CD 00 03                    CMP pac_position_x      ;   que pacman en X
0C602 D0 0E                       BNE +
0C604 BD 0E 03                    LDA ghost_position_y,X
0C607 CD 01 03                    CMP pac_position_y      ;   et en Y
0C60A D0 06                       BNE +
0C60C A9 03                       LDA #3           ; Si c'est le cas, le fantôme est mangé !
0C60E 9D 2A 03                    STA ghost_mode,X        ; Il faudrait ici augmenter le score...
0C611 60                          RTS
0C612                           +
0C612 DE 2E 03                    DEC ghost_timer,X       ; Si le fantôme n'est pas mangé, il repassera
0C615 D0 14                       BNE +
0C617 DE 32 03                    DEC ghost_timer_high,X
0C61A D0 0F                       BNE +
0C61C A9 00                       LDA #0          ;  dans le mode "coin" au bout d'un moment.
0C61E 9D 2A 03                    STA ghost_mode,X        ;  et on réinitialise le timer
0C621 A9 08                       LDA #8
0C623 9D 32 03                    STA ghost_timer_high,X
0C626 A9 2F                       LDA #47
0C628 9D 2E 03                    STA ghost_timer,X
0C62B 60                        + RTS
0C62C                           
0C62C                           ; Traitement du mode "mangé", retour à la base.
0C62C                           update_mode_eaten:
0C62C BD 0E 03                    LDA ghost_position_y,X ; Si on est rentré dans l'enclos
0C62F C9 0D                       CMP #13
0C631 D0 11                       BNE +
0C633 BD 0A 03                    LDA ghost_position_x,X
0C636 C9 0F                       CMP #15
0C638 D0 0A                       BNE +
0C63A A9 05                       LDA #5        ; On passe en mode attente pendant 1,2 secondes
0C63C 9D 2A 03                    STA ghost_mode,X
0C63F A9 3C                       LDA #60
0C641 9D 2E 03                    STA ghost_timer,X
0C644 60                        + RTS
0C645                           
0C645                           ; Traitement du mode "dans l'enclos"
0C645                           update_mode_in_pen:
0C645 BD 0E 03                    LDA ghost_position_y,X  ; On essaie juste de sortir
0C648 C9 0B                       CMP #11                 ;   et si on est assez haut,
0C64A D0 0F                       BNE +
0C64C A9 00                       LDA #0          ;   on repasse en mode coin
0C64E 9D 2A 03                    STA ghost_mode,X
0C651 A9 08                       LDA #8
0C653 9D 32 03                    STA ghost_timer_high,X
0C656 A9 2F                       LDA #47
0C658 9D 2E 03                    STA ghost_timer,X
0C65B 60                        + RTS
0C65C                           
0C65C                           ; Traitement du mode "Attente"
0C65C                           update_mode_waiting:
0C65C DE 2E 03                    DEC ghost_timer,X     ; On décrémente juste le timer
0C65F D0 05                       BNE +
0C661 A9 04                       LDA #4        ; Avant de changer de mode pour sortir de l'enclos
0C663 9D 2A 03                    STA ghost_mode,X
0C666 60                        + RTS
0C667                           
0C667                           
0C667                           ; Mise à jour de la cible du fantôme courant
0C667                           set_target:
0C667 BD 2A 03                    LDA ghost_mode,X           ; Suivant le mode de déplacement du fantôme
0C66A 20 C3 C8                    JSR on_goto                ; On utilise telle ou telle fonction
0C66D 79 C6                       DC.W set_target_corner
0C66F 86 C6                       DC.W set_target_chase
0C671 93 C6                       DC.W set_target_frightened
0C673 94 C6                       DC.W set_target_eaten
0C675 A0 C6                       DC.W set_target_in_pen
0C677 9F C6                       DC.W set_target_waiting
0C679                           
0C679                           ; Pour le mode "coin"
0C679                           set_target_corner:
0C679 BD 7A CE                    LDA default_target_x,X    ; On copie juste les coordonnées du
0C67C 9D 22 03                    STA ghost_target_x,X      ;  coin préféré du fantôme dans la cible
0C67F BD 7E CE                    LDA default_target_y,X
0C682 9D 26 03                    STA ghost_target_y,X
0C685 60                          RTS
0C686                           
0C686                           ; Pour le mode "pourchasse"
0C686                           set_target_chase:
0C686 AD 00 03                    LDA pac_position_x       ; La cible est simplement Pacman !
0C689 9D 22 03                    STA ghost_target_x,X     ;  (À améliorer pour plus d'intelligence !)
0C68C AD 01 03                    LDA pac_position_y
0C68F 9D 26 03                    STA ghost_target_y,X
0C692 60                          RTS
0C693                           
0C693                           ; Pour le mode effrayé
0C693                           set_target_frightened:
0C693 60                          RTS                      ; Il n'y a pas de cible dans ce mode...
0C694                           
0C694                           ; Pour le mode "mangé";
0C694                           set_target_eaten:          ; La cible est alors le centre
0C694 A9 0F                       LDA #15                  ;  de l'enclos.
0C696 9D 22 03                    STA ghost_target_x,X
0C699 A9 0D                       LDA #13
0C69B 9D 26 03                    STA ghost_target_y,X
0C69E 60                          RTS
0C69F                           
0C69F                           ; Pour le mode "attente"
0C69F                           set_target_waiting:
0C69F 60                          RTS                      ; Il n'y a pas de cible dans ce mode...
0C6A0                           
0C6A0                           ; Pour le mode "dans l'enclos"
0C6A0                           set_target_in_pen:
0C6A0 A9 0F                       LDA #15                 ; On vise une case au dessus de l'enclos pour arriver à sortir
0C6A2 9D 22 03                    STA ghost_target_x,X
0C6A5 A9 0A                       LDA #10
0C6A7 9D 26 03                    STA ghost_target_y,X
0C6AA 60                          RTS
0C6AB                           
0C6AB                           ;; Affichage du Pacman
0C6AB                           ;; On doit renseigner le X, le Y,
0C6AB                           ;;   le numéro de tuile et l'attributs
0C6AB                           ;;   de chacun des 4 sprites qui composent Pacman
0C6AB                           draw_pacman:
0C6AB                             ; D'abord les positions en X
0C6AB AD 00 03                    LDA pac_position_x  ; On récupère la position (en cases)
0C6AE 0A                          ASL                 ;  en X de Pacman
0C6AF 0A                          ASL                 ;   que l'on multiplie
0C6B0 0A                          ASL                 ;   par 8
0C6B1 18                          CLC                 ;   et on ajoute
0C6B2 6D 02 03                    ADC pac_sub_step_x  ;   la sous-position
0C6B5 E9 04                       SBC #4              ;  et on enlève 4 pixels
0C6B7 8D 03 02                    STA $203    ;  pour la partie gauche
0C6BA 8D 0B 02                    STA $20b    ;     des sprites
0C6BD 18                          CLC
0C6BE 69 08                       ADC #8          ;  et on ajoute 8 pixels
0C6C0 8D 07 02                    STA $207    ;    pour les sprites
0C6C3 8D 0F 02                    STA $20f    ;    de la partie droite
0C6C6                           
0C6C6                             ;
0C6C6 AD 01 03                    LDA pac_position_y  ; Même chose en Y
0C6C9 18                          CLC                 ; On tient compte des 2 lignes
0C6CA 69 02                       ADC #2              ;    au dessus du labyrinthe
0C6CC 0A                          ASL                 ; Multiplication par 8
0C6CD 0A                          ASL
0C6CE 0A                          ASL
0C6CF 18                          CLC                 ; On ajoute la sous-position
0C6D0 6D 03 03                    ADC pac_sub_step_y  ;  à l'intérieur de la case
0C6D3 38                          SEC                 ; Et on prend en compte le
0C6D4 E5 03                       SBC scroll_offset   ;   décalage de l'écran.
0C6D6 E9 04                       SBC #4              ; Puis on enlève 4 pixels
0C6D8 8D 00 02                    STA $200        ; ... pour la partie haute
0C6DB 8D 04 02                    STA $204
0C6DE 18                          CLC
0C6DF 69 08                       ADC #8
0C6E1 8D 08 02                    STA $208        ; ... et la partie basse
0C6E4 8D 0C 02                    STA $20c
0C6E7                           
0C6E7                             ; Le reste dépend de l'animation (ouvert, fermé)
0C6E7                             ; et de l'orientation
0C6E7 AD 09 03                    LDA pac_anim        ; On change l'animation
0C6EA 4A                          LSR                 ;   une fois sur deux
0C6EB 18                          CLC                 ; On se décale de 1 pour
0C6EC 69 01                       ADC #1              ;   commencer par la bonne position
0C6EE 29 03                       AND #3              ; On ne garde que les valeurs de 0 à 3
0C6F0 C9 03                       CMP #3              ;   et on transforme les 3
0C6F2 D0 02                       BNE +               ;    en 1
0C6F4 A9 01                       LDA #1              ;     pour avoir la séquence
0C6F6 0A                        + ASL                 ;       0,1,2,1,0,1,2,1,0,1,2,1,0,1,etc.
0C6F7 0A                          ASL                 ;     et on multiplie par huit pour avoir
0C6F8 0A                          ASL                 ;       0,8,16,8,0,8,16,8,0,8,16,8,etc.
0C6F9                           
0C6F9 AE 08 03                    LDX pac_orientation      ; Il reste à vérifier l'orientation de Pacman
0C6FC E0 00                       CPX #0  ; S'il va à gauche,
0C6FE D0 15                       BNE +
0C700 A8                          TAY             ; On copie A dans Y
0C701 8C 01 02                    STY $201 ;  qui contient le numéro de la tuile North West (NW)
0C704 C8                          INY             ; Et les suivantes
0C705 8C 05 02                    STY $205 ;  se suivent
0C708 C8                          INY             ;    dans l'ordre
0C709 8C 09 02                    STY $209 ;  NW, NE, SW et SE
0C70C C8                          INY             ; Par exemple, si A vaut 8
0C70D 8C 0D 02                    STY $20d ;  on utilisera les tuiles 8, 9, 10, 11
0C710 A0 00                       LDY #0          ; Pas de symétrie si on va à gauche
0C712 4C 63 C7                    JMP draw_pacman_attributes
0C715                           
0C715                           +
0C715 E0 01                       CPX #1
0C717 D0 15                       BNE +             ; Si on va à droite, on change
0C719 A8                          TAY               ;   juste l'ordre des tuiles
0C71A 8C 05 02                    STY $205   ;     entre Est et Ouest :
0C71D C8                          INY               ;     NE, NW, SE, SW
0C71E 8C 01 02                    STY $201
0C721 C8                          INY
0C722 8C 0D 02                    STY $20d
0C725 C8                          INY
0C726 8C 09 02                    STY $209
0C729 A0 40                       LDY #$40          ; Et on symétrise tout horizontalement
0C72B 4C 63 C7                    JMP draw_pacman_attributes
0C72E                           
0C72E                           +
0C72E E0 02                       CPX #2 ; Si on va vers le haut,
0C730 D0 18                       BNE +
0C732 18                          CLC               ;   on ajoute 4 pour sélectionner
0C733 69 04                       ADC #4            ;    les tuiles de la position
0C735 A8                          TAY               ;      verticale.
0C736 8C 01 02                    STY $201   ; Et le reste est identique.
0C739 C8                          INY
0C73A 8C 05 02                    STY $205
0C73D C8                          INY
0C73E 8C 09 02                    STY $209
0C741 C8                          INY
0C742 8C 0D 02                    STY $20d
0C745 A0 00                       LDY #0            ; Pas de symétrie
0C747 4C 63 C7                    JMP draw_pacman_attributes
0C74A                           
0C74A                           +
0C74A E0 03                       CPX #3 ; Et vers le bas,
0C74C D0 21                       BNE +                   ; C'est comme pour vers le haut
0C74E 18                          CLC
0C74F 69 04                       ADC #4
0C751 A8                          TAY
0C752 8C 09 02                    STY $209     ; mais on échange nord et sud
0C755 C8                          INY                 ; pour avoir l'ordre SW, SE, NW, NE
0C756 8C 0D 02                    STY $20d
0C759 C8                          INY
0C75A 8C 01 02                    STY $201
0C75D C8                          INY
0C75E 8C 05 02                    STY $205
0C761 A0 80                       LDY #$80            ; Et on symétrise verticalement
0C763                           
0C763                           draw_pacman_attributes:
0C763 8C 02 02                    STY $202  ; On stocke donc le même attribut
0C766 8C 06 02                    STY $206  ; pour les quatre tuiles :
0C769 8C 0A 02                    STY $20a  ; 0 si on va en haut ou à gauche
0C76C 8C 0E 02                    STY $20e  ; $40 pour la droite, $80 pour le bas.
0C76F 60                        + RTS
0C770                           
0C770                           ; Affichage des 4 fantômes
0C770                           ; Ici on appelle juste la sous fonction draw_one_ghost
0C770                           ; 4 fois, avec danx X le numéro de fantôme et dans Y
0C770                           ; l'emplacement en ram, dans la page $200 où seront
0C770                           ; stockées les informations (coordonnées x et y, tuile
0C770                           ; et attribut) de chaque sprite du fantôme
0C770                           draw_ghosts:
0C770 A2 00                       LDX #0             ; Le premier fantôme, Blinky,
0C772 A0 10                       LDY #$10           ;  utilise de $210 à $21f
0C774 20 8D C7                    JSR draw_one_ghost
0C777 A2 01                       LDX #1             ; Le second, Pinky,
0C779 A0 20                       LDY #$20           ;  utilise de $220 à $22f
0C77B 20 8D C7                    JSR draw_one_ghost
0C77E A2 02                       LDX #2             ; Le troisième, Inky,
0C780 A0 30                       LDY #$30           ;  utilise de $230 à $23f
0C782 20 8D C7                    JSR draw_one_ghost
0C785 A2 03                       LDX #3             ; Et le quatrième, Clyde,
0C787 A0 40                       LDY #$40           ;  utilise de $240 à $24f
0C789 20 8D C7                    JSR draw_one_ghost
0C78C 60                          RTS
0C78D                           
0C78D                           ; Affiche un fantôme.
0C78D                           ; Le numéro de fantôme doit être dans X
0C78D                           ; Et l'endroit où seront stockées ses infos dans Y
0C78D                           draw_one_ghost:
0C78D                             ; Rotation des associations fantôme <-> sprites
0C78D 8A                          TXA         ; On copie le numéro du fantôme dans A
0C78E 18                          CLC         ;   et on ajoute une valeur qui change
0C78F 65 01                       ADC vbl_cnt ;   toutes les frames
0C791 29 03                       AND #3      ; Puis, on se remet entre 0 et 3
0C793 AA                          TAX         ; Avant de remettre la valeur dans X
0C794                             ; On commence par la coordonné en x
0C794 BD 0A 03                    LDA ghost_position_x,X ; La position x en cases
0C797 0A                          ASL                    ;   est multipliée
0C798 0A                          ASL                    ;   par 8
0C799 0A                          ASL
0C79A E9 04                       SBC #4                 ; Puis on enlève 4 pixels
0C79C 18                          CLC     ; XXX
0C79D 7D 1A 03                    ADC ghost_sub_step_x,X
0C7A0 99 03 02                    STA $203,Y         ; pour la partie gauche
0C7A3 99 0B 02                    STA $20b,Y         ;    des sprites
0C7A6 18                          CLC
0C7A7 69 08                       ADC #8                 ; Et on ajoute 8 pixels
0C7A9 99 07 02                    STA $207,Y         ;   pour la partie droite
0C7AC 99 0F 02                    STA $20f,Y
0C7AF                           
0C7AF                             ; la coordonnée en y
0C7AF BD 0E 03                    LDA ghost_position_y,X ; Même chose en Y
0C7B2 18                          CLC                    ; On tient compte des 2 lignes vides
0C7B3 69 02                       ADC #2                 ;    au dessus du labyrinthe
0C7B5 0A                          ASL                    ; Multiplication par 8
0C7B6 0A                          ASL
0C7B7 0A                          ASL
0C7B8 38                          SEC                    ; On prend en compte le
0C7B9 E5 03                       SBC scroll_offset      ;   décalage de l'écran.
0C7BB E9 04                       SBC #4                 ; Puis on enlève 4 pixels
0C7BD 18                          CLC
0C7BE 7D 1E 03                    ADC ghost_sub_step_y,X
0C7C1 99 00 02                    STA $200,Y
0C7C4 99 04 02                    STA $204,Y
0C7C7 18                          CLC
0C7C8 69 08                       ADC #8                 ; Et 8 pixels plus bas
0C7CA 99 08 02                    STA $208,Y         ;   pour la partie basse des fantômes
0C7CD 99 0C 02                    STA $20c,Y
0C7D0                           
0C7D0                             ; Choix des tuiles
0C7D0 BD 2A 03                    LDA ghost_mode,X         ; Si le fantôme est dans l'état "mangé",
0C7D3 C9 03                       CMP #3
0C7D5 D0 03                       BNE +
0C7D7 4C 16 C8                    JMP draw_one_ghost_eaten ; on a un traitement particulier
0C7DA                           +
0C7DA C9 02                       CMP #2       ; Si le fantôme est effrayé,
0C7DC F0 03                       BEQ +
0C7DE 4C 5F C8                    JMP draw_one_ghost_not_frightened ; on ne passe pas à la suite.
0C7E1 A9 58                     + LDA #88                  ; Les tuiles des fantômes commencent au numéro 88
0C7E3 85 21                       STA ghost_anim_offset    ;
0C7E5 A5 01                       LDA vbl_cnt
0C7E7 29 08                       AND #%1000
0C7E9 F0 07                       BEQ +
0C7EB 18                          CLC
0C7EC A5 21                       LDA ghost_anim_offset    ; suivant l'animation on ajoute 4 ou non pour alterner
0C7EE 69 04                       ADC #4                   ; entre les deux formes de la robe des fantômes effrayés
0C7F0 85 21                       STA ghost_anim_offset
0C7F2                           +
0C7F2 A5 21                       LDA ghost_anim_offset    ; On renseigne alors les 4 tuiles pour ce fantôme
0C7F4 18                          CLC
0C7F5 99 01 02                    STA $201,Y  ; 88 ou 92
0C7F8 69 01                       ADC #1
0C7FA 99 05 02                    STA $205,Y  ; 89 ou 93
0C7FD 69 01                       ADC #1
0C7FF 99 09 02                    STA $209,Y  ; 90 ou 94
0C802 69 01                       ADC #1
0C804 99 0D 02                    STA $20d,Y  ; 91 ou 95
0C807                           
0C807 A9 03                       LDA #3             ; Et la palette est toujours la 3 (la quatrième, avec du bleu)
0C809 99 02 02                    STA $202,Y
0C80C 99 06 02                    STA $206,Y
0C80F 99 0A 02                    STA $20a,Y
0C812 99 0E 02                    STA $20e,Y
0C815 60                          RTS
0C816                           
0C816                           ; Dessin d'un fantôme mangé (juste ses yeux)
0C816                           draw_one_ghost_eaten:
0C816 A9 60                       LDA #96                 ; Les tuiles des yeux qui regardent à droite commencent à 96
0C818 85 21                       STA ghost_anim_offset
0C81A BD 12 03                    LDA ghost_direction_x,X
0C81D C9 FF                       CMP #-1
0C81F D0 04                       BNE +
0C821 A9 64                       LDA #100                ; Si le fantôme va à gauche, on prend les tuiles à partir de 100
0C823 85 21                       STA ghost_anim_offset
0C825                           +
0C825 BD 16 03                    LDA ghost_direction_y,X
0C828 C9 FF                       CMP #-1
0C82A D0 04                       BNE +
0C82C A9 68                       LDA #104                ; Si le fantôme va en haut, on prend les tuiles à partir de 104
0C82E 85 21                       STA ghost_anim_offset
0C830                           +
0C830 BD 16 03                    LDA ghost_direction_y,X
0C833 C9 01                       CMP #1
0C835 D0 04                       BNE +
0C837 A9 6C                       LDA #108                ; Si le fantôme va vers le bas, on prend les tuiles à partir de 108
0C839 85 21                       STA ghost_anim_offset
0C83B                           +
0C83B A5 21                       LDA ghost_anim_offset    ; On renseigne alors les 4 tuiles pour ce fantôme
0C83D 18                          CLC
0C83E 99 01 02                    STA $201,Y
0C841 69 01                       ADC #1
0C843 99 05 02                    STA $205,Y
0C846 69 01                       ADC #1
0C848 99 09 02                    STA $209,Y
0C84B 69 01                       ADC #1
0C84D 99 0D 02                    STA $20d,Y
0C850                           
0C850 A9 01                       LDA #1             ; Et on choisit la palette 1 !
0C852 99 02 02                    STA $202,Y
0C855 99 06 02                    STA $206,Y
0C858 99 0A 02                    STA $20a,Y
0C85B 99 0E 02                    STA $20e,Y
0C85E 60                          RTS
0C85F                           
0C85F                           ; Dessin des fantômes en mode normal
0C85F                           draw_one_ghost_not_frightened:
0C85F                             ; à partir de 24 pour les fantômes 0 et 2,
0C85F                             ;       et de 56 pour les fantômes 1 et 3
0C85F A9 00                       LDA #0                  ; Suivant la direction, on se décalera de 0 (droite)
0C861 85 21                       STA ghost_anim_offset
0C863 BD 12 03                    LDA ghost_direction_x,X
0C866 C9 FF                       CMP #-1
0C868 D0 04                       BNE +
0C86A A9 08                       LDA #8                  ; 8 (gauche)
0C86C 85 21                       STA ghost_anim_offset
0C86E                           +
0C86E BD 16 03                    LDA ghost_direction_y,X
0C871 C9 FF                       CMP #-1
0C873 D0 04                       BNE +
0C875 A9 10                       LDA #16                 ; 16 (haut)
0C877 85 21                       STA ghost_anim_offset
0C879                           +
0C879 BD 16 03                    LDA ghost_direction_y,X
0C87C C9 01                       CMP #1
0C87E D0 04                       BNE +
0C880 A9 18                       LDA #24                 ; ou 24 (bas)
0C882 85 21                       STA ghost_anim_offset
0C884                           +
0C884                           
0C884 A5 01                       LDA vbl_cnt
0C886 29 08                       AND #%1000
0C888 F0 07                       BEQ +
0C88A 18                          CLC
0C88B A5 21                       LDA ghost_anim_offset    ; suivant l'animation on ajoute 4 ou non pour alterner
0C88D 69 04                       ADC #4                   ; entre les deux formes de la robe des fantômes effrayés
0C88F 85 21                       STA ghost_anim_offset
0C891                           +
0C891 8A                          TXA
0C892 29 01                       AND #1  ; Si le numéro de fantôme est impair
0C894 F0 02                       BEQ +
0C896 A9 20                       LDA #32 ; On se décale de 32
0C898 18                        + CLC     ; (sinon, A contient déjà 0)
0C899 69 18                       ADC #24 ; et On ajoute 24
0C89B 65 21                       ADC ghost_anim_offset
0C89D                           
0C89D 99 01 02                    STA $201,Y  ; 24 ou 56 (plus animation)
0C8A0 69 01                       ADC #1
0C8A2 99 05 02                    STA $205,Y  ; 25 ou 57   "      "
0C8A5 69 01                       ADC #1
0C8A7 99 09 02                    STA $209,Y  ; 26 ou 58   "      "
0C8AA 69 01                       ADC #1
0C8AC 99 0D 02                    STA $20d,Y  ; 27 ou 59   "      "
0C8AF                           
0C8AF                             ; Palette : les deux premiers fantômes utilisent
0C8AF                             ; la palette 1, les deux autres la palette 2
0C8AF 8A                          TXA        ; On copie le numéro de fantôme dans A
0C8B0 29 02                       AND #%10   ; et on ne garde que le bit 1
0C8B2 4A                          LSR        ; A vaut alors 0 pour les deux premiers
0C8B3 18                          CLC        ;   fantômes et 1 pour les autres
0C8B4 69 01                       ADC #1     ; + 1, soit 1 ou 2, le bon numéro de palette
0C8B6 99 02 02                    STA $202,Y
0C8B9 99 06 02                    STA $206,Y
0C8BC 99 0A 02                    STA $20a,Y
0C8BF 99 0E 02                    STA $20e,Y
0C8C2 60                          RTS
0C8C3                           
0C8C3                           ; Fonction utilitaire
0C8C3                           ; Permet de sauter à une fonction en particulier en fonction de la valeur de A
0C8C3                           on_goto:
0C8C3 0A                          ASL                          ; On multiplie A par 2
0C8C4 A8                          TAY
0C8C5 68                          PLA                          ; On récupère l'adresse des adresses des fonctions dans la pile
0C8C6 85 04                       STA jump_address_pointer     ; Poids faible d'abord
0C8C8 68                          PLA
0C8C9 85 05                       STA jump_address_pointer + 1 ; Poids fort ensuite
0C8CB C8                          INY
0C8CC B1 04                       LDA (jump_address_pointer),y ; Puis on récupère l'adresse de la fonction qu'on veut appeler
0C8CE 85 06                       STA jump_address             ; Poids faible
0C8D0 C8                          INY
0C8D1 B1 04                       LDA (jump_address_pointer),y
0C8D3 85 07                       STA jump_address + 1         ; et poids fort
0C8D5 6C 06 00                    JMP (jump_address)           ; Et on saute à cette adresse
0C8D8                           
0C8D8                           ; Gestion des nombres aléatoire
0C8D8                           rand_init:   ; Initialisation avec
0C8D8 A9 11                       LDA #17    ;   un nombre que j'ai soigneusement choisi au hasard
0C8DA                           rand_seed:
0C8DA 85 00                       STA seed
0C8DC 60                          RTS
0C8DD                           
0C8DD                           ; Des calculs compliqués juste pour avoir une suite aléatoire intéressante.
0C8DD                           rand:
0C8DD                           rand23:
0C8DD A5 00                       LDA seed
0C8DF 0A                          ASL
0C8E0 0A                          ASL
0C8E1 18                          CLC
0C8E2 65 00                       ADC seed
0C8E4 18                          CLC
0C8E5 69 17                       ADC #23
0C8E7 85 00                       STA seed ; la prochaine valeur aléatoire est stockée dans seed et dans A
0C8E9 60                          RTS
0C8EA                           
0C8EA                           ;; Les données
0C8EA                           ;; La palette de couleurs
0C8EA                           palette:
0C8EA 0E 11 19 30 0E 15 16 17..   DC.B 14,17,25,48, 14,21,22,23, 14,25,26,27, 14,37,37,37
0C8FA 0E 28 19 19 0E 05 24 30..   DC.B 14,40,25,25, 14, 5,36,48, 14,60,23,48, 14, 2,49,25
0C90A                           
0C90A                           ; Les numéros des tuiles du labyrinthe
0C90A                           murs:
0C90A 20 20 20 20 20 20 20 20..   DC.B "                                "
0C92A 20 20 20 20 20 20 20 20..   DC.B "                                "
0C94A 00 00 01 02 02 02 02 02..   DC.B 0,0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5,0,0
0C96A 00 00 06 1E 1E 1E 1E 1E..   DC.B 0,0, 6,30,30,30,30,30,30,30,30,30,30,30,30, 7, 8,30,30,30,30,30,30,30,30,30,30,30,30, 9,0,0
0C98A 00 00 06 1E 0C 0A 0A 0D..   DC.B 0,0, 6,30,12,10,10,13,30,12,10,10,10,13,30, 7, 8,30,12,10,10,10,13,30,12,10,10,13,30, 9,0,0
0C9AA 00 00 06 1F 07 00 00 08..   DC.B 0,0, 6,31, 7, 0, 0, 8,30, 7, 0, 0, 0, 8,30, 7, 8,30, 7, 0, 0, 0, 8,30, 7, 0, 0, 8,31, 9,0,0
0C9CA 00 00 06 1E 0E 0B 0B 0F..   DC.B 0,0, 6,30,14,11,11,15,30,14,11,11,11,15,30,14,15,30,14,11,11,11,15,30,14,11,11,15,30, 9,0,0
0C9EA 00 00 06 1E 1E 1E 1E 1E..   DC.B 0,0, 6,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30, 9,0,0
0CA0A                           
0CA0A 00 00 06 1E 0C 0A 0A 0D..   DC.B 0,0, 6,30,12,10,10,13,30,12,13,30,12,10,10,10,10,10,10,13,30,12,13,30,12,10,10,13,30, 9,0,0
0CA2A 00 00 06 1E 0E 0B 0B 0F..   DC.B 0,0, 6,30,14,11,11,15,30, 7, 8,30,14,11,11,13,12,11,11,15,30, 7, 8,30,14,11,11,15,30, 9,0,0
0CA4A 00 00 06 1E 1E 1E 1E 1E..   DC.B 0,0, 6,30,30,30,30,30,30, 7, 8,30,30,30,30, 7, 8,30,30,30,30, 7, 8,30,30,30,30,30,30, 9,0,0
0CA6A 00 00 10 11 11 11 11 0D..   DC.B 0,0,16,17,17,17,17,13,30, 7,14,10,10,13, 0, 7, 8, 0,12,10,10,15, 8,30,12,17,17,17,17,18,0,0
0CA8A 00 00 00 00 00 00 00 06..   DC.B 0,0, 0, 0, 0, 0, 0, 6,30, 7,12,11,11,15, 0,14,15, 0,14,11,11,13, 8,30, 9, 0, 0, 0, 0, 0,0,0
0CAAA 00 00 00 00 00 00 00 06..   DC.B 0,0, 0, 0, 0, 0, 0, 6,30, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8,30, 9, 0, 0, 0, 0, 0,0,0
0CACA 00 00 00 00 00 00 00 06..   DC.B 0,0, 0, 0, 0, 0, 0, 6,30, 7, 8, 0,19,17,23,29,29,24,17,20, 0, 7, 8,30, 9, 0, 0, 0, 0, 0,0,0
0CAEA 02 02 02 02 02 02 02 0F..   DC.B 2,2, 2, 2, 2, 2, 2,15,30,14,15, 0, 9, 0, 0, 0, 0, 0, 0, 6, 0,14,15,30,14, 2, 2, 2, 2, 2,2,2
0CB0A                           
0CB0A 00 00 00 00 00 00 00 00..   DC.B 0,0, 0, 0, 0, 0, 0, 0,30, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0,30, 0, 0, 0, 0, 0, 0,0,0
0CB2A 11 11 11 11 11 11 11 0D..   DC.B 17,17,17,17,17,17,17,13,30,12,13, 0, 9, 0, 0, 0, 0, 0, 0, 6, 0,12,13,30,12,17,17,17,17,17,17,17
0CB4A 00 00 00 00 00 00 00 06..   DC.B 0,0, 0, 0, 0, 0, 0, 6,30, 7, 8, 0,21, 2, 2, 2, 2, 2, 2,22, 0, 7, 8,30, 9, 0, 0, 0, 0, 0,0,0
0CB6A 00 00 00 00 00 00 00 06..   DC.B 0,0, 0, 0, 0, 0, 0, 6,30, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8,30, 9, 0, 0, 0, 0, 0,0,0
0CB8A 00 00 00 00 00 00 00 06..   DC.B 0,0, 0, 0, 0, 0, 0, 6,30, 7, 8, 0,12,10,10,10,10,10,10,13, 0, 7, 8,30, 9, 0, 0, 0, 0, 0,0,0
0CBAA 00 00 01 02 02 02 02 0F..   DC.B 0,0, 1, 2, 2, 2, 2,15,30,14,15, 0,14,11,11,13,12,11,11,15, 0,14,15,30,14, 2, 2, 2, 2, 5,0,0
0CBCA 00 00 06 1E 1E 1E 1E 1E..   DC.B 0,0, 6,30,30,30,30,30,30,30,30,30,30,30,30, 7, 8,30,30,30,30,30,30,30,30,30,30,30,30, 9,0,0
0CBEA                           
0CBEA 00 00 06 1E 0C 0A 0A 0D..   DC.B 0,0, 6,30,12,10,10,13,30,12,10,10,10,13,30, 7, 8,30,12,10,10,10,13,30,12,10,10,13,30, 9,0,0
0CC0A 00 00 06 1E 0E 0B 0D 08..   DC.B 0,0, 6,30,14,11,13, 8,30,14,11,11,11,15,30,14,15,30,14,11,11,11,15,30, 7,12,11,15,30, 9,0,0
0CC2A 00 00 06 1F 1E 1E 07 08..   DC.B 0,0, 6,31,30,30, 7, 8,30,30,30,30,30,30,30, 0, 0,30,30,30,30,30,30,30, 7, 8,30,30,31, 9,0,0
0CC4A 00 00 19 0A 0D 1E 07 08..   DC.B 0,0,25,10,13,30, 7, 8,30,12,13,30,12,10,10,10,10,10,10,13,30,12,13,30, 7, 8,30,12,10,27,0,0
0CC6A 00 00 1A 0B 0F 1E 0E 0F..   DC.B 0,0,26,11,15,30,14,15,30, 7, 8,30,14,11,11,13,12,11,11,15,30, 7, 8,30,14,15,30,14,11,28,0,0
0CC8A 00 00 06 1E 1E 1E 1E 1E..   DC.B 0,0, 6,30,30,30,30,30,30, 7, 8,30,30,30,30, 7, 8,30,30,30,30, 7, 8,30,30,30,30,30,30, 9,0,0
0CCAA 00 00 06 1E 0C 0A 0A 0A..   DC.B 0,0, 6,30,12,10,10,10,10,15,14,10,10,13,30, 7, 8,30,12,10,10,15,14,10,10,10,10,13,30, 9,0,0
0CCCA                           
0CCCA                           murs2:
0CCCA 00 00 06 1E 0E 0B 0B 0B..   DC.B 0,0, 6,30,14,11,11,11,11,11,11,11,11,15,30,14,15,30,14,11,11,11,11,11,11,11,11,15,30, 9,0,0
0CCEA 00 00 06 1E 1E 1E 1E 1E..   DC.B 0,0, 6,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30, 9,0,0
0CD0A 00 00 10 11 11 11 11 11..   DC.B 0,0,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,18,0,0
0CD2A 20 20 20 20 20 20 20 20..   DC.B "                                "
0CD4A 20 20 20 20 20 20 20 20..   DC.B "                                "
0CD6A                           
0CD6A                           ; Table des murs, un bit par case, pour les collisions
0CD6A                           wall_mask_8bit:
0CD6A FF FF FF FF                 DC.B %11111111,%11111111,%11111111,%11111111 ; ligne 0
0CD6E E0 01 80 07                 DC.B %11100000,%00000001,%10000000,%00000111 ; ligne 1
0CD72 EF 7D BE F7                 DC.B %11101111,%01111101,%10111110,%11110111 ; ligne 2
0CD76 EF 7D BE F7                 DC.B %11101111,%01111101,%10111110,%11110111 ; ligne 3
0CD7A EF 7D BE F7                 DC.B %11101111,%01111101,%10111110,%11110111 ; ligne 4
0CD7E E0 00 00 07                 DC.B %11100000,%00000000,%00000000,%00000111 ; ligne 5
0CD82 EF 6F F6 F7                 DC.B %11101111,%01101111,%11110110,%11110111 ; ligne 6
0CD86 EF 6F F6 F7                 DC.B %11101111,%01101111,%11110110,%11110111 ; ligne 7
0CD8A E0 61 86 07                 DC.B %11100000,%01100001,%10000110,%00000111 ; ligne 8
0CD8E FF 7D BE FF                 DC.B %11111111,%01111101,%10111110,%11111111 ; ligne 9
0CD92 FF 7D BE FF                 DC.B %11111111,%01111101,%10111110,%11111111 ; ligne 10
0CD96 FF 60 06 FF                 DC.B %11111111,%01100000,%00000110,%11111111 ; ligne 11
0CD9A FF 6E 76 FF                 DC.B %11111111,%01101110,%01110110,%11111111 ; ligne 12
0CD9E FF 68 16 FF                 DC.B %11111111,%01101000,%00010110,%11111111 ; ligne 13
0CDA2 00 08 10 00                 DC.B %00000000,%00001000,%00010000,%00000000 ; ligne 14
0CDA6 FF 6F F6 FF                 DC.B %11111111,%01101111,%11110110,%11111111 ; ligne 15
0CDAA FF 6F F6 FF                 DC.B %11111111,%01101111,%11110110,%11111111 ; ligne 16
0CDAE FF 60 06 FF                 DC.B %11111111,%01100000,%00000110,%11111111 ; ligne 17
0CDB2 FF 6F F6 FF                 DC.B %11111111,%01101111,%11110110,%11111111 ; ligne 18
0CDB6 FF 6F F6 FF                 DC.B %11111111,%01101111,%11110110,%11111111 ; ligne 19
0CDBA E0 01 80 07                 DC.B %11100000,%00000001,%10000000,%00000111 ; ligne 20
0CDBE EF 7D BE F7                 DC.B %11101111,%01111101,%10111110,%11110111 ; ligne 21
0CDC2 EF 7D BE F7                 DC.B %11101111,%01111101,%10111110,%11110111 ; ligne 22
0CDC6 E3 00 00 C7                 DC.B %11100011,%00000000,%00000000,%11000111 ; ligne 23
0CDCA FB 6F F6 DF                 DC.B %11111011,%01101111,%11110110,%11011111 ; ligne 24
0CDCE FB 6F F6 DF                 DC.B %11111011,%01101111,%11110110,%11011111 ; ligne 25
0CDD2 E0 61 86 07                 DC.B %11100000,%01100001,%10000110,%00000111 ; ligne 26
0CDD6 EF FD BF F7                 DC.B %11101111,%11111101,%10111111,%11110111 ; ligne 27
0CDDA EF FD BF F7                 DC.B %11101111,%11111101,%10111111,%11110111 ; ligne 28
0CDDE E0 00 00 07                 DC.B %11100000,%00000000,%00000000,%00000111 ; ligne 29
0CDE2 FF FF FF FF                 DC.B %11111111,%11111111,%11111111,%11111111 ; ligne 30
0CDE6                           
0CDE6                           ; Table des pilules, au démarrage du jeu
0CDE6                           starting_pills:
0CDE6 00 00 00 00                 DC.B %00000000,%00000000,%00000000,%00000000 ; ligne 0
0CDEA 1F FE 7F F8                 DC.B %00011111,%11111110,%01111111,%11111000 ; ligne 1
0CDEE 10 82 41 08                 DC.B %00010000,%10000010,%01000001,%00001000 ; ligne 2
0CDF2 10 82 41 08                 DC.B %00010000,%10000010,%01000001,%00001000 ; ligne 3
0CDF6 10 82 41 08                 DC.B %00010000,%10000010,%01000001,%00001000 ; ligne 4
0CDFA 1F FF FF F8                 DC.B %00011111,%11111111,%11111111,%11111000 ; ligne 5
0CDFE 10 90 09 08                 DC.B %00010000,%10010000,%00001001,%00001000 ; ligne 6
0CE02 10 90 09 08                 DC.B %00010000,%10010000,%00001001,%00001000 ; ligne 7
0CE06 1F 9E 79 F8                 DC.B %00011111,%10011110,%01111001,%11111000 ; ligne 8
0CE0A 00 80 01 00                 DC.B %00000000,%10000000,%00000001,%00000000 ; ligne 9
0CE0E 00 80 01 00                 DC.B %00000000,%10000000,%00000001,%00000000 ; ligne 10
0CE12 00 80 01 00                 DC.B %00000000,%10000000,%00000001,%00000000 ; ligne 11
0CE16 00 80 01 00                 DC.B %00000000,%10000000,%00000001,%00000000 ; ligne 12
0CE1A 00 80 01 00                 DC.B %00000000,%10000000,%00000001,%00000000 ; ligne 13
0CE1E 00 80 01 00                 DC.B %00000000,%10000000,%00000001,%00000000 ; ligne 14
0CE22 00 80 01 00                 DC.B %00000000,%10000000,%00000001,%00000000 ; ligne 15
0CE26 00 80 01 00                 DC.B %00000000,%10000000,%00000001,%00000000 ; ligne 16
0CE2A 00 80 01 00                 DC.B %00000000,%10000000,%00000001,%00000000 ; ligne 17
0CE2E 00 80 01 00                 DC.B %00000000,%10000000,%00000001,%00000000 ; ligne 18
0CE32 00 80 01 00                 DC.B %00000000,%10000000,%00000001,%00000000 ; ligne 19
0CE36 1F FE 7F F8                 DC.B %00011111,%11111110,%01111111,%11111000 ; ligne 20
0CE3A 10 82 41 08                 DC.B %00010000,%10000010,%01000001,%00001000 ; ligne 21
0CE3E 10 82 41 08                 DC.B %00010000,%10000010,%01000001,%00001000 ; ligne 22
0CE42 1C FE 7F 38                 DC.B %00011100,%11111110,%01111111,%00111000 ; ligne 23
0CE46 04 90 09 20                 DC.B %00000100,%10010000,%00001001,%00100000 ; ligne 24
0CE4A 04 90 09 20                 DC.B %00000100,%10010000,%00001001,%00100000 ; ligne 25
0CE4E 1F 9E 79 F8                 DC.B %00011111,%10011110,%01111001,%11111000 ; ligne 26
0CE52 10 02 40 08                 DC.B %00010000,%00000010,%01000000,%00001000 ; ligne 27
0CE56 10 02 40 08                 DC.B %00010000,%00000010,%01000000,%00001000 ; ligne 28
0CE5A 1F FF FF F8                 DC.B %00011111,%11111111,%11111111,%11111000 ; ligne 29
0CE5E 00 00 00 00                 DC.B %00000000,%00000000,%00000000,%00000000 ; ligne 30
0CE62                           
0CE62                           ghost_default_values:
0CE62 10 10 0E 12                 DC.B 16, 16, 14, 18   ; position x
0CE66 0B 0E 0E 0E                 DC.B 11, 14, 14, 14   ; position y
0CE6A 01 00 01 FF                 DC.B  1,  0,  1, -1   ; direction x
0CE6E 00 FF 00 00                 DC.B  0, -1,  0,  0   ; direction y
0CE72 00 00 FD FD                 DC.B  0,  0, -3, -3   ; sub_step x
0CE76 00 00 00 00                 DC.B  0,  0,  0,  0   ; sub_step y
0CE7A                           default_target_x:
0CE7A 1C 05 05 1C                 DC.B 28,  5,  5, 28   ; target x
0CE7E                           default_target_y:
0CE7E 00 21 00 21                 DC.B  0, 33,  0, 33   ; target y  (-2)
0CE82 00 05 05 05                 DC.B 0, 5, 5, 5 ; mode de déplacement
0CE86 00 50 A0 F0                 DC.B  0, 80, 160, 240 ; timer
0CE8A 03 00 00 00                 DC.B  3,  0,  0,  0   ; timer_high
0CE8E                           
0CE8E                             ;; Les vecteurs du 6502
0CE8E 00 00 00 00 00 00 00 00..   ORG $FFFA
0FFFA 39 C1                       DC.W VBL    ; Appelé à chaque début d'image
0FFFC 00 C0                       DC.W RESET  ; Appelé au lancement
0FFFE 00 00                       DC.W $0000  ; Inutilisé
10000                           
10000 00 00 07 03 01 00 00 00..   INCBIN "gfx.chr"  ; la ROM du PPU
12000                           
